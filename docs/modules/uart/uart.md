# UART

## Sub-modules

- [UART RX](uart_rx.md)
- [UART TX](uart_tx.md)

## Description

## Generics

<div class="generics-table" markdown="1">

| Generic Name      | Type     | Default Value | Description                                    |
| ----------------- | -------- | ------------- | ---------------------------------------------- |
| `G_CLK_FREQ_HZ`   | positive | 0d50_000_000  | Clock frequency in Hz of `CLK`                 |
| `G_BAUD_RATE_BPS` | positive | 0d115_200     | Baud rate in bps                               |
| `G_SAMPLING_RATE` | positive | 0d16          | Sampling rate (number of clock cycles per bit) |
| `G_NB_DATA_BITS`  | positive | 0d8           | Number of data bits                            |

</div>

## Inputs and Outputs

<div class="ports-table" markdown="1">

| Port Name                | Type         | Direction | Default Value | Description                          |
| ------------------------ | ------------ | :-------: | ------------- | ------------------------------------ |
| `CLK`                    | std_logic    |    in     | -             | Input clock                          |
| `RST_N`                  | std_logic    |    in     | -             | Input asynchronous reset, active low |
| `I_UART_RX`              | std_logic    |    in     | -             | Asynchronous input UART RX line      |
| `O_UART_TX`              | std_logic    |    out    | 0b1           | Output UART TX line                  |
| `O_READ_ADDR`            | vector[7:0]  |    out    | 0x00          | Output read address                  |
| `O_READ_ADDR_VALID`      | std_logic    |    out    | 0b0           | Output read address valid flag       |
| `I_READ_DATA`            | vector[15:0] |    in     | -             | Input read data                      |
| `I_READ_DATA_ADDR_VALID` | std_logic    |    in     | -             | Input read data valid                |
| `O_WRITE_ADDR`           | vector[7:0]  |    out    | 0x00          | Output write address                 |
| `O_WRITE_DATA`           | vector[15:0] |    out    | 0x0000        | Output write data                    |
| `O_WRITE_VALID`          | std_logic    |    out    | 0b0           | Output write valid flag              |

</div>

## Architecture

![UART Architecture](../../assets/uart.drawio){ page="UART" }

### Protocol

The implemented UART protocol is an ASCII-based protocol to access the internal registers of the FPGA.
All commands and responses are ASCII text and every message is terminated by a mandatory carriage-return (CR, `\r`).
A line-feed (LF, `\n`) may follow CR but is optional and ignored by the device.

The following fields are defined:

- `AA`: 8-bit address (two ASCII hex characters)
- `DDDD`: 16-bit data (four ASCII hex characters)

![UART Protocol Diagram](../../assets/uart.drawio){ page="UART-PROTOCOL" }

#### Read Mode

The read mode allows reading a 16-bit value from a specified 8-bit register address. The device responds with the
current register value.

**Command Format**:

```raw
R + AA + \r[\n]
```

- `R`: literal ASCII 'R' (read command)
- `AA`: two ASCII hex characters representing an 8-bit address (`00` .. `FF`)
- `\r`: mandatory CR terminator (ASCII 0x0D)
- `\n`: optional LF (ASCII 0x0A), if present it is ignored by the device

**Response Format**:

```raw
DDDD + \r[\n]
```

- `DDDD`: four ASCII hex characters representing the 16-bit register value, MSB first (`0000` .. `FFFF`)
- `\r`: mandatory CR terminator
- `\n`: optional LF (ASCII 0x0A)

**Examples**:

```none
# Read address 0x1A
Sent                   : R1A\r\n
Bytes transmitted (hex): 0x52 0x31 0x41 0x0D 0x0A
Reply                  : 0F3C\r
Bytes received    (hex): 0x30 0x46 0x33 0x43 0x0D
```

```none
# Read address 0xFF
Sent                   : RFF\r
Bytes transmitted (hex): 0x52 0x46 0x46 0x0D
Reply                  : DEAD\r
Bytes received    (hex): 0x44 0x45 0x39 0x44 0x0D
```

---

#### Write Mode

The write mode allows writing a 16-bit value to a specified 8-bit register address.
The device does not send any acknowledgment response after a successful write operation.

**Command Format**:

```raw
W + AA + DDDD + \r[\n]
```

- `W`: literal ASCII 'W' (write command)
- `AA`: two ASCII hex characters representing an 8-bit address (`00` .. `FF`)
- `DDDD`: four ASCII hex characters representing the 16-bit data value to write, MSB first (`0000` .. `FFFF`)
- `\r`: mandatory CR terminator (ASCII 0x0D)
- `\n`: optional LF (ASCII 0x0A), if present it is ignored by the device

**Response Format**:

No response is expected or generated by the device for write commands.

!!! important
    To verify that data was correctly written to the given address, perform a read-back operation using the read
    command on the same register address.

**Example**:

```none
# Write value 0x1234 to address 0x1A
Sent                   : W1A1234\r\n
Bytes transmitted (hex): 0x57 0x31 0x41 0x31 0x32 0x33 0x34 0x0D 0x0A
Reply                  : (no reply expected)
```

```none
# Write value 0x0001 to address 0x01
Sent                   : W010001\r
Bytes transmitted (hex): 0x57 0x30 0x31 0x30 0x30 0x30 0x31 0x0D
Reply                  : (no reply expected)
```

#### Special behavior

Some transitions have special behavior: at every character received, the FSM checks if it is an `R` or `W` character.
If detected, the FSM immediately abandons any ongoing operation and starts processing the new command.

This means that a new read or write command can interrupt and completely override a partially received command, even if
the previous command was not yet complete.

**Example**: Interrupted Write Command

```none
# Sending the following ASCII characters: W001R00\r
#                                              â†‘
#                              Sudden change to read command,
#                              even though write command was incomplete
Sent       : W001R00\r
Expected   : Write incomplete data to address 0x00
Actual     : Read from address 0x00
Result     : Returns the data at address 0x00
             No write operation is performed
```

---

### FSM

The UART FSM handling the above protocol is defined as:

![UART FSM](../../assets/uart.drawio){ page="UART-FSM" }

Where the following transitions are defined:

| Transition | Condition(s)                                                                   |
| ---------- | ------------------------------------------------------------------------------ |
| T0         | `tx_byte_count >= 5`                                                           |
| T1         | Automatic                                                                      |
| T2         | `rx_byte_valid = 1` **AND** `(rx_byte = R character or rx_byte = W character)` |
| T3         | `rx_byte = W character`                                                        |
| T4         | `rx_byte = R character`                                                        |
| T5         | `rx_byte /= CR (\r) character` **AND** `rx_byte_count >= 3`                    |
| T6         | `rx_byte = CR (\r) character` **AND** `rx_byte_count >= 3`                     |
| T7         | Automatic                                                                      |
| T8         | `I_READ_DATA_VALID = 1`                                                        |
| T9         | `rx_byte /= CR (\r) character` **AND** `rx_byte_count >= 7`                    |
| T10        | `rx_byte = CR (\r) character` **AND** `rx_byte_count >= 7`                     |

---

### Data decoding

The received data needs to be decoded from ASCII to hexadecimal to be usable in the registers.
To do so, the signal `rx_byte_decoded` receives:

#### ASCII to Hexadecimal Decoding

| Decoded Value | ASCII Character | Condition        |
| ------------- | --------------- | ---------------- |
| `0x0`         | '0'             | `rx_byte = 0x30` |
| `0x1`         | '1'             | `rx_byte = 0x31` |
| `0x2`         | '2'             | `rx_byte = 0x32` |
| `0x3`         | '3'             | `rx_byte = 0x33` |
| `0x4`         | '4'             | `rx_byte = 0x34` |
| `0x5`         | '5'             | `rx_byte = 0x35` |
| `0x6`         | '6'             | `rx_byte = 0x36` |
| `0x7`         | '7'             | `rx_byte = 0x37` |
| `0x8`         | '8'             | `rx_byte = 0x38` |
| `0x9`         | '9'             | `rx_byte = 0x39` |
| `0xA`         | 'A'             | `rx_byte = 0x41` |
| `0xB`         | 'B'             | `rx_byte = 0x42` |
| `0xC`         | 'C'             | `rx_byte = 0x43` |
| `0xD`         | 'D'             | `rx_byte = 0x44` |
| `0xE`         | 'E'             | `rx_byte = 0x45` |
| `0xF`         | 'F'             | `rx_byte = 0x46` |

#### Decoding Special Characters

| Character       | ASCII Value | Condition      |
| --------------- | ----------- | -------------- |
| Default/Invalid | `0x00`      | No match found |

---

### Data encoding

The transmit data needs to be encoded from hexadecimal to ASCII before being sent over UART.
To do so, the signal `tx_byte_to_send_encoded` receives:

#### Hexadecimal to ASCII Encoding

| Input Value | ASCII Character | Encoded Value                    |
| ----------- | --------------- | -------------------------------- |
| `0x0`       | '0'             | `tx_byte_to_send_encoded = 0x30` |
| `0x1`       | '1'             | `tx_byte_to_send_encoded = 0x31` |
| `0x2`       | '2'             | `tx_byte_to_send_encoded = 0x32` |
| `0x3`       | '3'             | `tx_byte_to_send_encoded = 0x33` |
| `0x4`       | '4'             | `tx_byte_to_send_encoded = 0x34` |
| `0x5`       | '5'             | `tx_byte_to_send_encoded = 0x35` |
| `0x6`       | '6'             | `tx_byte_to_send_encoded = 0x36` |
| `0x7`       | '7'             | `tx_byte_to_send_encoded = 0x37` |
| `0x8`       | '8'             | `tx_byte_to_send_encoded = 0x38` |
| `0x9`       | '9'             | `tx_byte_to_send_encoded = 0x39` |
| `0xA`       | 'A'             | `tx_byte_to_send_encoded = 0x41` |
| `0xB`       | 'B'             | `tx_byte_to_send_encoded = 0x42` |
| `0xC`       | 'C'             | `tx_byte_to_send_encoded = 0x43` |
| `0xD`       | 'D'             | `tx_byte_to_send_encoded = 0x44` |
| `0xE`       | 'E'             | `tx_byte_to_send_encoded = 0x45` |
| `0xF`       | 'F'             | `tx_byte_to_send_encoded = 0x46` |

#### Encoding Special Characters

| Character            | ASCII Value | Condition                         |
| -------------------- | ----------- | --------------------------------- |
| Carriage Return (CR) | `0x0D`      | `tx_byte_count = C_TX_DATA_BYTES` |
| Default/Invalid      | `0x00`      | No match found                    |

---
