{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"UART PROJECT","text":"<p>Documentation of the UART Project for the Zedboard device.</p>"},{"location":"#overview","title":"Overview","text":"<p>An UART-based FPGA peripheral control system featuring some basic IPs from scratch (UART, SPI, VGA, etc.) and IPs from Open Logic FPGA Standard Library.</p> <p>Verification with <code>Vunit</code> framework and <code>nvc</code> simulator with code coverage.</p> <p>Synthesis and implementation are done with Vivado.</p>"},{"location":"#list-of-abbreviations","title":"List of Abbreviations","text":"Abbreviation Definition ASCII American Standard Code for Information Interchange CR Carriage Return CS Chip Select FIFO First In, First Out FPGA Field-Programmable Gate Array FSM Finite State Machine I/O Input/Output LF Line Feed LSB Least Significant Bit LVCMOS Low Voltage Complementary Metal-Oxide-Semiconductor MISO Master In Slave Out MOSI Master Out Slave In MSB Most Significant Bit PLL Phase-Locked Loop RTL Register Transfer Level RX Receive SCLK Serial Clock SPI Serial Peripheral Interface TX Transmit UART Universal Asynchronous Receiver-Transmitter VGA Video Graphics Array VHDL VHSIC Hardware Description Language VHSIC Very High Speed Integrated Circuit"},{"location":"#tools-versions","title":"Tools Versions","text":"Tool Version NVC <code>nvc 1.18.2 (1.18.2. r0.g8893318a5) (Using LLVM 18.1.3)</code> Vunit <code>commit 1d9f0bdbf917dd486ae7f0902d54598a0b206719</code> VSG <code>VHDL Style Guide (VSG) version: 3.35.0</code> Vivado <code>2025.1</code>"},{"location":"#clocking-configuration","title":"Clocking Configuration","text":"<p>The FPGA uses a PLL (<code>clk_wiz_0</code>) to generate internal clocks from the input clock.</p> Signal Name Type Frequency Description PLL Input <code>clk_in1</code> Clock 100 MHz Input clock from <code>PAD_I_CLK</code> (Y9) PLL Outputs <code>clk_out1</code> Clock 50 MHz Internal system clock (<code>internal_clk</code>) <code>clk_out2</code> Clock 65 MHz VGA clock (<code>vga_clk</code>) <code>locked</code> Status - PLL lock indicator (<code>pll_locked</code>)"},{"location":"#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>The FPGA defines the following inputs/outputs:</p> Pin Name Pin Number Direction Resistor Slew IOSTANDARD <code>PAD_I_CLK</code> Y9 in - - LVCMOS33 <code>PAD_RST_H</code> BTN6 in - - LVCMOS18 <code>PAD_I_UART_RX</code> Y11 in PULL-UP - LVCMOS33 <code>PAD_O_UART_TX</code> AA11 out PULL-UP - LVCMOS33 <code>PAD_O_SCLK</code> W12 out - - LVCMOS33 <code>PAD_O_MOSI</code> W11 out - - LVCMOS33 <code>PAD_I_MISO</code> W10 in - - LVCMOS33 <code>PAD_O_CS_N</code> W8 out PULL-UP - LVCMOS33 <code>PAD_I_SWITCH_0</code> F22 in - - LVCMOS18 <code>PAD_I_SWITCH_1</code> G22 in - - LVCMOS18 <code>PAD_I_SWITCH_2</code> H22 in - - LVCMOS18 <code>PAD_O_LED_0</code> T22 out - - LVCMOS33 <code>PAD_O_VGA_BLUE[0]</code> Y21 out - - LVCMOS33 <code>PAD_O_VGA_BLUE[1]</code> Y20 out - - LVCMOS33 <code>PAD_O_VGA_BLUE[2]</code> AB20 out - - LVCMOS33 <code>PAD_O_VGA_BLUE[3]</code> AB19 out - - LVCMOS33 <code>PAD_O_VGA_GREEN[0]</code> AB22 out - - LVCMOS33 <code>PAD_O_VGA_GREEN[1]</code> AA22 out - - LVCMOS33 <code>PAD_O_VGA_GREEN[2]</code> AB21 out - - LVCMOS33 <code>PAD_O_VGA_GREEN[3]</code> AA21 out - - LVCMOS33 <code>PAD_O_VGA_RED[0]</code> V20 out - - LVCMOS33 <code>PAD_O_VGA_RED[1]</code> U20 out - - LVCMOS33 <code>PAD_O_VGA_RED[2]</code> V19 out - - LVCMOS33 <code>PAD_O_VGA_RED[3]</code> V18 out - - LVCMOS33 <code>PAD_O_VGA_HSYNC</code> AA19 out - - LVCMOS33 <code>PAD_O_VGA_VSYNC</code> Y19 out - - LVCMOS33"},{"location":"#design-architecture","title":"Design architecture","text":"<ul> <li>FPGA modules</li> </ul>"},{"location":"#testbench","title":"Testbench","text":"<ul> <li>Testbench description</li> <li>Testcases description</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python:  Version 3.10 or higher</li> <li>NVC: Version r1.18.2</li> <li>Vivado: Version 2025.1</li> </ul>"},{"location":"usage/#installation","title":"Installation","text":""},{"location":"usage/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>Clone the repo and initialize the submodules:</p> <pre><code>git clone --recursive https://github.com/CharrierTim/uart.git\ncd uart\n</code></pre> <p>If you already cloned the repository without <code>--recursive</code>, initialize the submodules:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"usage/#2-set-up-python-environment","title":"2. Set Up Python Environment","text":"<p>Create a Python virtual environment and install the required dependencies:</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install .\n</code></pre>"},{"location":"usage/#running-tests","title":"Running Tests","text":"<p>Important</p> <p>Make sure to compile Unisim/Unifast libraries (e.g., <code>nvc --install vivado</code>). If Unisim/Unifast libraries are not found when running the tests, you can update the script <code>bench/top_fpga/run.py</code> and update the line <code>simulator.add_library(library_name=\"unisim\", library_path=\"your_path_to_unisim\")</code>.</p>"},{"location":"usage/#basic-test-execution","title":"Basic Test Execution","text":"<p>To run the top-level FPGA testbench:</p> <pre><code>python3 bench/top_fpga/run.py\n</code></pre>"},{"location":"usage/#parallel-execution","title":"Parallel Execution","text":"<p>Run testcases in parallel using multiple threads for faster execution:</p> <pre><code>python3 bench/top_fpga/run.py -p0\n</code></pre> <p>Where:</p> <ul> <li><code>-p0</code>: Runs each testcase in a separate thread (auto-detects number of CPU cores)</li> <li><code>-p&lt;N&gt;</code>: Runs with N parallel threads (e.g., <code>-p4</code> for 4 threads)</li> </ul>"},{"location":"usage/#coverage-analysis","title":"Coverage Analysis","text":"<p>Enable code coverage collection and generate an HTML coverage report:</p> <pre><code>python3 bench/top_fpga/run.py --coverage\n</code></pre> <p>The coverage report will be generated in the <code>vunit_out/coverage_report</code> folder. Open <code>vunit_out/coverage_report/index.html</code> in your browser to view the results.</p>"},{"location":"usage/#generating-the-bitstream","title":"Generating the bitstream","text":"<p>Run the following command in the <code>synthesis</code> folder:</p> <pre><code>vivado -mode batch -nojournal -script run_synthesis.tcl\n</code></pre>"},{"location":"modules/top_fpga/","title":"Top FPGA","text":""},{"location":"modules/top_fpga/#description","title":"Description","text":"<p>Top-Level of the FPGA.</p>"},{"location":"modules/top_fpga/#overview","title":"Overview","text":"<p>The following figure depicts the Top-Level:</p> <p></p>"},{"location":"modules/top_fpga/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_GIT_ID</code> vector[31:0] 0x0000 Git ID containing the sources for the bitstream generation. Automatically set by the <code>run_synthesis. tcl</code> script."},{"location":"modules/top_fpga/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>PAD_I_CLK</code> std_logic in - Input clock <code>PAD_I_RST_H</code> std_logic in - Input asynchronous reset, active high <code>PAD_I_UART_RX</code> std_logic in - Input UART RX line <code>PAD_O_UART_TX</code> std_logic out 0b1 Output UART TX line <code>PAD_O_SCLK</code> std_logic out 0b0 Output SPI serial clock <code>PAD_O_MOSI</code> std_logic out 0b0 Output SPI Master Output Slave Input <code>PAD_I_MISO</code> std_logic in - Output SPI Master Input Slave Input <code>PAD_O_CS_N</code> std_logic out 0b1 Output SPI Chip Select <code>O_HSYNC</code> std_logic out 0b0 Horizontal sync signal output <code>O_VSYNC</code> std_logic out 0b0 Vertical sync signal output <code>O_RED</code> vector[3:0] out 0x00 Red color channel output (blanked during inactive regions) <code>O_GREEN</code> vector[3:0] out 0x00 Green color channel output (blanked during inactive regions) <code>O_BLUE</code> vector[3:0] out 0x00 Blue color channel output (blanked during inactive regions) <code>PAD_I_SWITCH_0</code> std_logic in - Input switch 0 <code>PAD_I_SWITCH_1</code> std_logic in - Input switch 1 <code>PAD_I_SWITCH_2</code> std_logic in - Input switch 2 <code>PAD_O_LED_0</code> std_logic out 0b1 Output LED 0"},{"location":"modules/top_fpga/#architecture","title":"Architecture","text":""},{"location":"modules/top_fpga/#internal-reset","title":"Internal Reset","text":"<p>The FPGA internal reset <code>internal_rst_n</code> signal is generated by combining two conditions:</p> <ol> <li>The external reset button <code>PAD_I_RST_H</code> (active-high)</li> <li>The PLL lock status <code>pll_locked</code></li> </ol> <p>This ensures that the internal logic remains in reset until both the reset button is released or the PLL is unlocked.</p> <p>Then, the FPGA resynchronize the asynchronous reset signal to both clock domain to ensure synchronous de-assertion of the reset.</p> <p>The FPGA instantiates the olo_base_reset_gen module with the following generics for the system clock domain reset:</p> Generic Name Type Default Value Description <code>RstPulseCycles_g</code> positive 0d3 Minimum duration of the reset pulse in clock cycles <code>RstInPolarity_g</code> std_logic 0b1 Polarity of 'RstIn'. <code>AsyncResetOutput_g</code> boolean false False -&gt; Reset signal is asserted synchronously. <code>SyncStages_g</code> positive 0d3 Number of synchronization stages for the multi-stage synchronizer. <p>The FPGA instantiates the olo_base_reset_gen module with the following generics for the VGA clock domain reset:</p> Generic Name Type Default Value Description <code>RstPulseCycles_g</code> positive 0d3 Minimum duration of the reset pulse in clock cycles <code>RstInPolarity_g</code> std_logic 0b1 Polarity of 'RstIn'. <code>AsyncResetOutput_g</code> boolean false False -&gt; Reset signal is asserted synchronously. <code>SyncStages_g</code> positive 0d3 Number of synchronization stages for the multi-stage synchronizer."},{"location":"modules/top_fpga/#olo_intf_sync","title":"olo_intf_sync","text":"<p>The FPGA instantiates the olo_intf_sync module with the following generics:</p> Generic Name Type Default Value Description <code>Width_g</code> positive 0d3 Number of data bits <code>RstLevel_g</code> std_logic 0b000 Value to set the synchronizer registers to upon reset. <code>SyncStages_g</code> positive 0b000 Number of synchronization stages."},{"location":"modules/top_fpga/#uart","title":"UART","text":"<p>The FPGA instantiates the uart module with the following generics:</p> Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>internal_clk</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps <code>G_SAMPLING_RATE</code> positive 0d16 Sampling rate (number of clock cycles per bit)"},{"location":"modules/top_fpga/#regfile","title":"Regfile","text":"<p>The FPGA instantiates the regfile module with the following generics:</p> Generic Name Type Default Value Description <code>G_GIT_ID_MSB</code> vector[15:0] <code>G_GIT_ID[31:16]</code> 16 MSB of the git ID containing the sources for the bitstream generation <code>G_GIT_ID_LSB</code> vector[15:0] <code>G_GIT_ID[15:0]</code> 16 LSB of the git ID containing the sources for the bitstream generation"},{"location":"modules/top_fpga/#spi-master","title":"SPI Master","text":"<p>The FPGA instantiates the spi_master module with the following generics:</p> Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>internal_clk</code> <code>G_SPI_FREQ_HZ</code> positive 0d1_000_000 SPI clock frequency in Hz <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits within the SPI transaction <code>G_CLK_POLARITY</code> std_logic 0b0 Generated SPI clock polarity <code>G_CLK_PHASE</code> std_logic 0b0 Generated SPI clock phase"},{"location":"modules/top_fpga/#vga","title":"VGA","text":"<p>The FPGA instantiates the vga_controller module with the following generics:</p> Generic Name Type Default Value Description <code>G_H_PIXELS</code> integer 0d1024 Horizontal resolution in pixels <code>G_H_FRONT_PORCH</code> integer 0d24 Horizontal front porch in pixels <code>G_H_SYNC_PULSE</code> integer 0d136 Horizontal synchronization pulse in pixels <code>G_H_BACK_PORCH</code> integer 0d160 Horizontal back porch in pixels <code>G_V_PIXELS</code> integer 0d768 Vertical resolution in pixels <code>G_V_FRONT_PORCH</code> integer 0d3 Vertical front porch in pixels <code>G_V_SYNC_PULSE</code> integer 0d6 Vertical synchronization pulse in pixels <code>G_V_BACK_PORCH</code> integer 0d29 Vertical back porch in pixels"},{"location":"modules/regfile/regfile/","title":"Registers","text":""},{"location":"modules/regfile/regfile/#description","title":"Description","text":"<p>Internal FPGA registers with read/write registers accessible via the UART line.</p>"},{"location":"modules/regfile/regfile/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_GIT_ID_MSB</code> vector[15:0] 0x0000 16 MSB of the git ID containing the sources for the bitstream generation <code>G_GIT_ID_LSB</code> vector[15:0] 0x0000 16 LSB of the git ID containing the sources for the bitstream generation"},{"location":"modules/regfile/regfile/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_P</code> std_logic in - Input asynchronous reset, active low <code>I_SWITCHES</code> vector[2:0] in - Input vector containing the resynchronized switches value <code>I_SPI_RX_DATA</code> vector[7:0] in - Input vector containing the SPI data sent by the slave <code>I_SPI_RX_DATA_VALID</code> std_logic in - Input vector containing the SPI data sent flag valid <code>I_READ_ADDR</code> vector[7:0] in - Read address from the UART <code>I_READ_ADDR_VALID</code> std_logic in - Read address valid flag <code>O_READ_DATA</code> vector[15:0] out <code>G_GIT_ID_MSB</code> Read data at the address <code>I_READ_ADDR</code> <code>O_READ_DATA_VALID</code> std_logic out 0x00 Read data valid flag <code>I_WRITE_ADDR</code> vector[7:0] in - Write address from the UART <code>I_WRITE_DATA</code> vector[15:0] in - Write data to be written at <code>I_WRITE_DATA</code> <code>I_WRITE_VALID</code> std_logic in - Write address and data valid flag <code>O_SPI_TX_DATA</code> vector[7:0] out 0x00 Input vector containing the SPI data to be send <code>O_SPI_TX_DATA_VALID</code> std_logic out 0b0 Input vector containing the SPI data flag valid <code>O_LED_0</code> std_logic out 0b1 LED 0 value <code>O_VGA_COLORS</code> vector[11:0] out 0x000 Output colors channels to be displayed on the VGA. Bits[11:8] for red, bits[7:4] for green channel, bits[3:0] for blue channel"},{"location":"modules/regfile/regfile/#architecture","title":"Architecture","text":""},{"location":"modules/regfile/regfile/#read-operations","title":"Read Operations","text":"<p>The regfile module performs a read operation when <code>I_READ_ADDR_VALID</code> is asserted (set to '1'). The module responds by:</p> <ol> <li>Reading the data stored at the address specified by <code>I_READ_ADDR</code></li> <li>Asserting <code>O_READ_DATA_VALID</code> on the next clock cycle</li> <li>Outputting the retrieved value on <code>O_READ_DATA</code></li> </ol> <p>Invalid Address Handling:</p> <p>If the specified address does not correspond to a defined register, the module returns the sentinel value <code>0xDEAD</code> to indicate an invalid read operation.</p> <pre><code>Valid address:   I_READ_ADDR_VALID = '1' \u2192 O_READ_DATA = register[I_READ_ADDR]\nInvalid address: I_READ_ADDR_VALID = '1' \u2192 O_READ_DATA = 0xDEAD\n</code></pre>"},{"location":"modules/regfile/regfile/#write-operations","title":"Write Operations","text":"<p>The regfile module performs a write operation when <code>I_WRITE_VALID</code> is asserted (set to '1'). The module writes the data from <code>I_WRITE_DATA</code> to the address specified by <code>I_WRITE_ADDR</code>.</p> <p>Write Protection:</p> <p>Not all registers are writable. If the specified address corresponds to:</p> <ul> <li>A read-only register: The write operation is silently ignored, and   the register value remains unchanged</li> <li>A writable register: The data is written on the next clock cycle</li> <li>An undefined address: The write operation is ignored</li> </ul>"},{"location":"modules/regfile/regfile/#overview","title":"Overview","text":"<p>A simplified view of the regfile module:</p> <p></p>"},{"location":"modules/regfile/regfile/#summary","title":"Summary","text":"Name Address Mode Description REG_GIT_ID_MSB 0x00 R 16 MSB of the git ID containing the sources for the bitstream generation REG_GIT_ID_LSB 0x01 R 16 LSB of the git ID containing the sources for the bitstream generation REG_12 0x02 R Internal register 1 REG_34 0x03 R Internal register 2 REG_56 0x04 R Internal register 3 REG_78 0x05 R Internal register 4 REG_SPI_TX 0x06 RW Register controlling the SPI data to send REG_SPI_RX 0x07 R Register containing the SPI slave data REG_VGA_CTRL 0x08 RW Register controlling the output color of the VGA module REG_9A 0xAB R Internal register 5 REG_CD 0xAC R Internal register 6 REG_EF 0xDC R Internal register 7 REG_SWITCHES 0xB1 R Status from the input switches REG_LED 0xEF RW Register with LSB bit writable controlling an LED REG_16_BITS 0xFF RW Register with all bits writable <p>Where:</p> Mode Description R Read-only: Register value can be read but not modified via write operations RW Read-Write: Register value can be both read and written"},{"location":"modules/regfile/regfile/#detailed-register-descriptions","title":"Detailed register descriptions","text":""},{"location":"modules/regfile/regfile/#reg_git_id_msb","title":"REG_GIT_ID_MSB","text":"<p>16 MSB of the git ID containing the sources for the bitstream generation</p> <ul> <li>Address: <code>0x00</code></li> </ul> Bits Reset Name Description 15:0 0x0 GIT_ID_MSB Most significant 16 bits of the Git commit ID"},{"location":"modules/regfile/regfile/#reg_git_id_lsb","title":"REG_GIT_ID_LSB","text":"<p>16 LSB of the git ID containing the sources for the bitstream generation</p> <ul> <li>Address: <code>0x01</code></li> </ul> Bits Reset Name Description 15:0 0x0 GIT_ID_LSB Least significant 16 bits of the Git commit ID"},{"location":"modules/regfile/regfile/#reg_12","title":"REG_12","text":"<p>Internal register 1</p> <ul> <li>Address: <code>0x02</code></li> </ul> Bits Reset Name Description 15:0 0x1212 Constant"},{"location":"modules/regfile/regfile/#reg_34","title":"REG_34","text":"<p>Internal register 2</p> <ul> <li>Address: <code>0x03</code></li> <li>Reset default: <code>0x3434</code></li> </ul> Bits Reset Name Description 15:0 0x3434 - Constant"},{"location":"modules/regfile/regfile/#reg_56","title":"REG_56","text":"<p>Internal register 3</p> <ul> <li>Address: <code>0x04</code></li> <li>Reset default: <code>0x5656</code></li> </ul> Bits Reset Name Description 15:0 0x5656 - Constant"},{"location":"modules/regfile/regfile/#reg_spi_tx","title":"REG_SPI_TX","text":"<p>SPI TX data register</p> <ul> <li>Address: <code>0x06</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:9 0x0 - Reserved 8 0x0 TX_DATA_VALID 0 -&gt; 1 start the SPI transaction 7:0 0x0 TX_DATA TX data to be sent"},{"location":"modules/regfile/regfile/#reg_spi_rx","title":"REG_SPI_RX","text":"<p>SPI RX data register</p> <ul> <li>Address: <code>0x07</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:8 0x0 - Reserved 7:0 0x0 RX_DATA Received data from SPI slave"},{"location":"modules/regfile/regfile/#reg_vga_ctrl","title":"REG_VGA_CTRL","text":"<p>VGA colors data register</p> <ul> <li>Address: <code>0x08</code></li> <li>Reset default: <code>0x00F0</code></li> </ul> Bits Reset Name Description 15:12 0x0 - Reserved 11:8 0x0 RED Red channel 7:4 0xF GREEN Green channel 3:0 0x0 BLUE Blue channel"},{"location":"modules/regfile/regfile/#reg_78","title":"REG_78","text":"<p>Internal register 4</p> <ul> <li>Address: <code>0x05</code></li> <li>Reset default: <code>0x7878</code></li> </ul> Bits Reset Name Description 15:0 0x7878 - Constant"},{"location":"modules/regfile/regfile/#reg_9a","title":"REG_9A","text":"<p>Internal register 5</p> <ul> <li>Address: <code>0xAB</code></li> <li>Reset default: <code>0x9A9A</code></li> </ul> Bits Reset Name Description 15:0 0x9A9A - Constant"},{"location":"modules/regfile/regfile/#reg_cd","title":"REG_CD","text":"<p>Internal register 6</p> <ul> <li>Address: <code>0xAC</code></li> <li>Reset default: <code>0xCDCD</code></li> </ul> Bits Reset Name Description 15:0 0xCDCD - Constant"},{"location":"modules/regfile/regfile/#reg_ef","title":"REG_EF","text":"<p>Internal register 7</p> <ul> <li>Address: <code>0xDC</code></li> <li>Reset default: <code>0xEFEF</code></li> </ul> Bits Reset Name Description 15:0 0xEFEF - Constant"},{"location":"modules/regfile/regfile/#reg_switches","title":"REG_SWITCHES","text":"<p>Register returning the status of the input switches</p> <ul> <li>Address: <code>0xB1</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:3 0x0 - Reserved 2 0x0 SWITCH_2 Signal from PAD_I_SWITCH_2 1 0x0 SWITCH_1 Signal from PAD_I_SWITCH_1 0 0x0 SWITCH_0 Signal from PAD_I_SWITCH_0"},{"location":"modules/regfile/regfile/#reg_led","title":"REG_LED","text":"<p>Register with LSB bit writable controlling an LED</p> <ul> <li>Address: <code>0xEF</code></li> <li>Reset default: <code>0x0001</code></li> </ul> Bits Reset Name Description 15:1 0x0 - Reserved 0 0x1 LED_0 Writable bit"},{"location":"modules/regfile/regfile/#reg_16_bits","title":"REG_16_BITS","text":"<p>Register with all bits writable</p> <ul> <li>Address: <code>0xFF</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:0 0x0 DATA 16-bit writable data field"},{"location":"modules/spi/spi_master/","title":"SPI Master","text":""},{"location":"modules/spi/spi_master/#description","title":"Description","text":""},{"location":"modules/spi/spi_master/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>internal_clk</code> <code>G_SPI_FREQ_HZ</code> positive 0d500_000 SPI clock frequency in Hz <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits within the SPI transaction <code>G_CLK_POLARITY</code> std_logic 0b0 Generated SPI clock polarity <code>G_CLK_PHASE</code> std_logic 0b0 Generated SPI clock phase"},{"location":"modules/spi/spi_master/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_P</code> std_logic in - Input asynchronous reset, active low <code>O_SCLK</code> std_logic out <code>G_CLK_POLARITY</code> Output SPI serial clock <code>O_MOSI</code> std_logic out 0b0 Output Master Out Slave In <code>I_MISO</code> std_logic in - Input Master In Slave Out <code>O_CS</code> std_logic out 0b1 Output chip select <code>I_TX_DATA</code> vector[G_NB_DATA_BITS-1:0] in - Data to be sent <code>I_TX_DATA_VALID</code> std_logic in - Data to be sent flag valid. Must be a rising edge to start the transaction (0 -&gt; 1) <code>O_TX_DATA</code> vector[G_NB_DATA_BITS-1:0] out 0x00 Data received from the slave <code>O_TX_DATA_VALID</code> std_logic out 0b0 Data Data received from the slave flag valid"},{"location":"modules/spi/spi_master/#architecture","title":"Architecture","text":""},{"location":"modules/spi/spi_master/#configurations","title":"Configurations","text":"<p>The SPI master supports all four standard SPI modes, determined by the Clock Polarity (CPOL) and Clock Phase (CPHA) settings:</p>"},{"location":"modules/spi/spi_master/#mode-0-cpol0-cpha0","title":"Mode 0: CPOL=0, CPHA=0","text":"<p>In this mode:</p> <ul> <li>Clock idles low</li> <li>Data is output on the rising edge of SCLK</li> <li>Input data is sampled on the falling edge of SCLK</li> </ul>"},{"location":"modules/spi/spi_master/#mode-1-cpol0-cpha1","title":"Mode 1: CPOL=0, CPHA=1","text":"<p>In this mode:</p> <ul> <li>Clock idles low</li> <li>Data is output on the falling edge of SCLK</li> <li>Input data is sampled on the rising edge of SCLK</li> </ul>"},{"location":"modules/spi/spi_master/#mode-2-cpol1-cpha0","title":"Mode 2: CPOL=1, CPHA=0","text":"<p>In this mode:</p> <ul> <li>Clock idles high</li> <li>Data is output on the falling edge of SCLK</li> <li>Input data is sampled on the rising edge of SCLK</li> </ul>"},{"location":"modules/spi/spi_master/#mode-3-cpol1-cpha1","title":"Mode 3: CPOL=1, CPHA=1","text":"<p>In this mode:</p> <ul> <li>Clock idles high</li> <li>Data is output on the rising edge of SCLK</li> <li>Input data is sampled on the falling edge of SCLK</li> </ul> <p>Note</p> <p>\"Output\" refers to when data is driven onto the MOSI/MISO lines. \"Sampled\" refers to when data is captured/registered from the input line.</p>"},{"location":"modules/spi/spi_master/#fsm","title":"FSM","text":"<p>The UART FSM handling is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>i_data_valid_d1 = 0</code> AND <code>I_DATA_VALID = 1</code> (rising edge) T1 <code>spi_enable_sampling = 1</code> (trailing edge) T2 <code>spi_enable_shifting = 1</code> (leading edge) T3 <code>bit_counter &gt;= G_NB_DATA_BITS - 1</code> AND <code>spi_enable_shifting = 1</code> (all bits sent) T4 <code>spi_enable_sampling = 1</code> (trailing edge) T5 Automatic"},{"location":"modules/testbench/tb_top_fpga/","title":"Testbench description","text":""},{"location":"modules/testbench/tb_top_fpga/#overview","title":"Overview","text":"<p>The following figure depicts the Testbench:</p> <p></p>"},{"location":"modules/testbench/tb_top_fpga/#types","title":"Types","text":""},{"location":"modules/testbench/tb_top_fpga/#t_reg","title":"t_reg","text":"<p>A record type used to define register configurations for the testbench.</p> Property Description Type Name <code>t_reg</code> Purpose Register fields with address and default value Fields - <code>name</code> :  <code>string</code> - Register name identifier- <code>addr</code> : <code>std_logic_vector(7 downto 0)</code> - 8-bit register address- <code>data</code> : <code>std_logic_vector(15 downto 0)</code> - 16-bit reset value"},{"location":"modules/testbench/tb_top_fpga/#constants","title":"Constants","text":""},{"location":"modules/testbench/tb_top_fpga/#general-constants","title":"General constants","text":"<p>The following constants are defined:</p> Name Type Value Description <code>C_FREQ_HZ</code> positive 0d100_000_000 Clock frequency <code>C_CLK_PERIOD</code> time 1 sec / <code>C_FREQ_HZ</code> Clock period <code>C_GIT_ID</code> vector[31: 0] 0x12345678 Git identifier for DUT version tracking <code>C_UART_BAUD_RATE_BPS</code> positive 0d115_200 UART baud rate in bits per second <code>C_UART_BIT_TIME</code> time 1 sec / <code>C_UART_BAUD_RATE_BPS</code> Time duration for one UART bit <code>C_UART_BIT_TIME_ACCURACY</code> time 0. 01 * <code>C_UART_BIT_TIME</code> UART bit timing tolerance (1%) <code>C_UART_WRITE_NB_BITS</code> positive 10 * 8 Total bits for UART write command <code>C_UART_WRITE_CMD_TIME</code> time <code>C_UART_BIT_TIME</code> * <code>C_UART_WRITE_NB_BITS</code> Total time for UART write command <code>C_READ_NB_BITS</code> positive 10 * 9 Total bits for UART read command <code>C_UART_READ_CMD_TIME</code> time <code>C_UART_BIT_TIME</code> * <code>C_UART_READ_NB_BITS</code> Total time for UART read command <code>C_SPI_FREQ_HZ</code> positive 0d1_000_000 SPI SLCK frequency <code>C_SPI_BIT_TIME</code> time 1 sec / <code>C_SPI_FREQ_HZ</code> SPI baud rate in bits per second <code>C_SPI_BIT_TIME_ACCURACY</code> time 0.01 * <code>C_SPI_BIT_TIME</code> SPI bit timing tolerance (1%) <code>C_SPI_NB_DATA_BIS</code> positive 8 Total bits in SPI transaction <code>C_SPI_TRANSACTION_TIME</code> time (<code>C_SPI_NB_DATA_BIS</code> + 2) * <code>C_SPI_BIT_TIME</code> SPI transaction time <code>C_H_VGA_PIXEL_FREQUENCY</code> integer 0d65_000_000 VGA pixel clock frequency <code>C_H_VGA_PIXEL_BIT_TIME</code> time 1 sec / <code>C_H_VGA_PIXEL_FREQUENCY</code> VGA pixel clock period <code>C_H_PIXELS</code> integer 0d1024 VGA active display width (pixels) <code>C_H_FRONT_PORCH</code> integer 0d24 VGA horizontal front porch (pixels) <code>C_H_SYNC_PULSE</code> integer 0d136 VGA horizontal sync pulse width (pixels) <code>C_H_BACK_PORCH</code> integer 0d160 VGA horizontal back porch (pixels) <code>C_H_HSYNC_HIGH</code> integer <code>C_H_PIXELS</code> + <code>C_H_FRONT_PORCH</code> + <code>C_H_BACK_PORCH</code> VGA horizontal sync high period (pixels) <code>C_H_WHOLE_LINE</code> integer <code>C_H_SYNC_PULSE</code> + <code>C_H_HSYNC_HIGH</code> VGA total horizontal line (pixels) <code>C_H_SYNC_PULSE_TIME</code> time <code>C_H_SYNC_PULSE</code> * <code>C_H_VGA_PIXEL_BIT_TIME</code> VGA horizontal sync pulse duration <code>C_H_SYNC_PULSE_TIME_ACCURACY</code> time 0.01 * <code>C_H_SYNC_PULSE</code> * <code>C_H_VGA_PIXEL_BIT_TIME</code> VGA horizontal sync pulse tolerance <code>C_H_HSYNC_HIGH_TIME</code> time <code>C_H_HSYNC_HIGH</code> * <code>C_H_VGA_PIXEL_BIT_TIME</code> VGA horizontal sync high duration <code>C_H_HSYNC_HIGH_TIME_ACCURACY</code> time 0.01 * <code>C_H_HSYNC_HIGH</code> * <code>C_H_VGA_PIXEL_BIT_TIME</code> VGA horizontal sync high tolerance <code>C_H_WHOLE_LINE_TIME</code> time <code>C_H_SYNC_PULSE_TIME</code> + <code>C_H_HSYNC_HIGH_TIME</code> VGA total horizontal line duration <code>C_H_WHOLE_LINE_TIME_ACCURACY</code> time <code>C_H_SYNC_PULSE_TIME_ACCURACY</code> + <code>C_H_HSYNC_HIGH_TIME_ACCURACY</code> VGA total horizontal line tolerance <code>C_V_VGA_PIXEL_FREQUENCY</code> integer <code>C_H_VGA_PIXEL_FREQUENCY</code> / <code>C_H_WHOLE_LINE</code> VGA line frequency (Hz) <code>C_V_VGA_PIXEL_BIT_TIME</code> time 1 sec / <code>C_V_VGA_PIXEL_FREQUENCY</code> VGA line period <code>C_V_PIXELS</code> integer 0d768 VGA active display height (lines) <code>C_V_FRONT_PORCH</code> integer 0d3 VGA vertical front porch (lines) <code>C_V_SYNC_PULSE</code> integer 0d6 VGA vertical sync pulse width (lines) <code>C_V_BACK_PORCH</code> integer 0d29 VGA vertical back porch (lines) <code>C_V_HSYNC_HIGH</code> integer <code>C_V_PIXELS</code> + <code>C_V_FRONT_PORCH</code> + <code>C_V_BACK_PORCH</code> VGA vertical sync high period (lines) <code>C_V_WHOLE_LINE</code> integer <code>C_V_SYNC_PULSE</code> + <code>C_V_HSYNC_HIGH</code> VGA total vertical frame (lines) <code>C_V_SYNC_PULSE_TIME</code> time <code>C_V_SYNC_PULSE</code> * <code>C_V_VGA_PIXEL_BIT_TIME</code> VGA vertical sync pulse duration <code>C_V_SYNC_PULSE_TIME_ACCURACY</code> time 0.01 * <code>C_V_SYNC_PULSE</code> * <code>C_V_VGA_PIXEL_BIT_TIME</code> VGA vertical sync pulse tolerance <code>C_V_HSYNC_HIGH_TIME</code> time <code>C_V_HSYNC_HIGH</code> * <code>C_V_VGA_PIXEL_BIT_TIME</code> VGA vertical sync high duration <code>C_V_HSYNC_HIGH_TIME_ACCURACY</code> time 0.01 * <code>C_V_HSYNC_HIGH</code> * <code>C_V_VGA_PIXEL_BIT_TIME</code> VGA vertical sync high tolerance <code>C_V_WHOLE_LINE_TIME</code> time <code>C_V_SYNC_PULSE_TIME</code> + <code>C_V_HSYNC_HIGH_TIME</code> VGA total vertical frame duration <code>C_V_WHOLE_LINE_TIME_ACCURACY</code> time <code>C_V_SYNC_PULSE_TIME_ACCURACY</code> + <code>C_V_HSYNC_HIGH_TIME_ACCURACY</code> VGA total vertical frame tolerance"},{"location":"modules/testbench/tb_top_fpga/#registers","title":"Registers","text":"<p>The following registers are defined as <code>t_reg</code>:</p> Name Address Reset Value <code>C_REG_GIT_ID_MSB</code> 0x00 0x1234 <code>C_REG_GIT_ID_LSB</code> 0x01 0x5678 <code>C_REG_12</code> 0x02 0x1212 <code>C_REG_34</code> 0x03 0x3434 <code>C_REG_56</code> 0x04 0x5656 <code>C_REG_78</code> 0x05 0x7878 <code>C_REG_SPI_TX</code> 0x06 0x0000 <code>C_REG_SPI_RX</code> 0x07 0x0000 <code>C_REG_SPI_RX</code> 0x07 0x0000 <code>C_REG_VGA_CTRL</code> 0x08 0x00F0 <code>C_REG_9A</code> 0xAB 0x9A9A <code>C_REG_CD</code> 0xAC 0xCDCD <code>C_REG_EF</code> 0xDC 0xEFEF <code>C_REG_SWITCHES</code> 0xB1 0x0000 <code>C_REG_LED</code> 0xEF 0x0001 <code>C_REG_16_BITS</code> 0xFF 0x0000 <code>C_REG_DEAD</code> 0xCC 0xDEAD"},{"location":"modules/testbench/tb_top_fpga/#processes","title":"Processes","text":""},{"location":"modules/testbench/tb_top_fpga/#process-p_check_uart_timings","title":"Process <code>p_check_uart_timings</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description","title":"Description","text":"<p>Verifies UART TX timings by transmitting test data <code>0x5555</code> and measuring bit durations.</p> <p>Data Conversion:</p> <ul> <li>Test data <code>0x5555</code> contains four <code>'5'</code> characters</li> <li>Each <code>'5'</code> is converted to ASCII \u2192 <code>0x35</code> (binary: <code>00110101</code>)</li> </ul> <p>UART Frame Structure:</p> <p>Each character is transmitted as a 10-bit frame:</p> <pre><code>[Start] [Bit0 Bit1 Bit2 Bit3 Bit4 Bit5 Bit6 Bit7] [Stop]\n  0       1    0    1    0    1    1    0    0      1\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 LSB to MSB \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The diagram below shows the waveform and which falling/rising edges are awaited:</p> <p>In total, it is repeated four times.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters","title":"Parameters","text":"<p>The process defines two variables:</p> Parameter Type Default Description <code>v_start_time</code> <code>time</code> - The start time of the measurement <code>v_start_bit_time</code> <code>time</code> - The start time of the measurement of a bit state"},{"location":"modules/testbench/tb_top_fpga/#steps","title":"Steps","text":"<ol> <li> <p>Wait for the start of UART timings check</p> <ul> <li>Wait for a rising edge on signal <code>tb_check_uart_timings</code></li> <li>Log info message: \"Checking UART timings on TX with value 0x5555\"</li> </ul> </li> <li> <p>For each byte (1 to 4)</p> <ul> <li>Wait for start bit<ul> <li>Wait for falling edge on <code>tb_pad_o_uart_tx</code> (a)</li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>If first byte, set <code>v_start_time</code> to current time</li> </ul> </li> <li>Wait for a rising edge on signal <code>tb_pad_o_uart_tx</code> (b)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>C_UART_BIT_TIME</code> \u00b1 <code>C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>Wait for a falling edge on signal <code>tb_pad_o_uart_tx</code> (c)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>C_UART_BIT_TIME</code> \u00b1 <code>C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>Wait for a rising edge on signal <code>tb_pad_o_uart_tx</code> (d)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>C_UART_BIT_TIME</code> \u00b1 <code>C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>Wait for a falling edge on signal <code>tb_pad_o_uart_tx</code> (e)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>C_UART_BIT_TIME</code> \u00b1 <code>C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>Wait for a rising edge on signal <code>tb_pad_o_uart_tx</code> (f)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>C_UART_BIT_TIME</code> \u00b1 <code>C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>Wait for a falling edge on signal <code>tb_pad_o_uart_tx</code> (g)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>2. 0 * C_UART_BIT_TIME</code> \u00b1 <code>2.0 * C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> <li>Wait for a rising edge on signal <code>tb_pad_o_uart_tx</code> (h)</li> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>2.0 * C_UART_BIT_TIME</code> \u00b1 <code>2.0 * C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> </ul> </li> <li> <p>Verify total elapsed time</p> <ul> <li>Check that <code>(now - v_start_time)</code> is in time range 9 * 4 <code>C_UART_BIT_TIME</code> \u00b1 <code>C_UART_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#process-p_check_spi_timings","title":"Process <code>p_check_spi_timings</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_1","title":"Description","text":"<p>Verifies SPI clock timings.</p> <p>Currently only verifies SPI clock timings.</p> <p>The diagram below shows the waveform and which rising edges are awaited:</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_1","title":"Parameters","text":"<p>The process defines two variables:</p> Parameter Type Default Description <code>v_start_time</code> <code>time</code> - The start time of the measurement <code>v_start_bit_time</code> <code>time</code> - The start time of the measurement of a bit state"},{"location":"modules/testbench/tb_top_fpga/#steps_1","title":"Steps","text":"<ol> <li> <p>Wait for the start of SPI timings check</p> <ul> <li>Wait for a rising edge on signal <code>tb_check_spi_timings</code></li> </ul> </li> <li> <p>For each bit (1 to 8)</p> <ul> <li>Wait for a rising edge on signal <code>tb_pad_o_sclk</code> (a to h)</li> <li>If first bit (<code>bits = 1</code>):<ul> <li>Set <code>v_start_time</code> to current time</li> <li>Set <code>v_start_bit_time</code> to current time</li> </ul> </li> <li>Else:<ul> <li>Check that <code>(now - v_start_bit_time)</code> is in time range <code>C_SPI_BIT_TIME</code> \u00b1 <code>C_SPI_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> <li>Set <code>v_start_bit_time</code> to current time</li> </ul> </li> </ul> </li> <li> <p>Verify total elapsed time</p> <ul> <li>Check that <code>(now - v_start_time)</code> is in time range <code>7 * C_SPI_BIT_TIME</code> \u00b1 <code>7 * C_SPI_BIT_TIME_ACCURACY</code> with procedure <code>proc_check_time_in_range</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#process-p_check_hsync_timings","title":"Process <code>p_check_hsync_timings</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_2","title":"Description","text":"<p>This process verifies the VGA horizontal synchronization (HSYNC) timing.</p> <p></p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_2","title":"Parameters","text":"<p>The process defines two variables:</p> Parameter Type Default Description <code>v_start_time</code> <code>time</code> - The start time of the measurement <code>v_start_bit_time</code> <code>time</code> - The start time of the measurement of a bit state"},{"location":"modules/testbench/tb_top_fpga/#steps_2","title":"Steps","text":"<ol> <li> <p>Wait for the start of HSYNC timings check</p> <ul> <li>Wait for a rising edge on signal <code>tb_check_hsync_timings</code></li> </ul> </li> <li> <p>Measure HSYNC pulse width (sync pulse duration)</p> <ul> <li>Wait for falling edge on <code>tb_pad_o_vga_hsync</code> (start of sync pulse)</li> <li>Capture both <code>v_start_time</code> and <code>v_start_bit_time</code> as baseline</li> <li>Wait for rising edge on <code>tb_pad_o_vga_hsync</code> (end of sync pulse)</li> <li>Validate sync pulse duration against <code>C_H_SYNC_PULSE_TIME</code> \u00b1 <code>C_H_SYNC_PULSE_TIME_ACCURACY</code></li> <li>Update <code>v_start_bit_time</code> to current time</li> </ul> </li> <li> <p>Measure HSYNC high period and total line time</p> <ul> <li>Wait for next falling edge on <code>tb_pad_o_vga_hsync</code> (completion of one horizontal line)</li> <li>Validate high period:  Check time since last edge against <code>C_H_HSYNC_HIGH_TIME</code> \u00b1 <code>C_H_HSYNC_HIGH_TIME_ACCURACY</code></li> <li>Validate complete line time: Check time since initial <code>v_start_time</code> against <code>C_H_WHOLE_LINE_TIME</code> \u00b1 <code>C_H_WHOLE_LINE_TIME_ACCURACY</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#process-p_check_vsync_timings","title":"Process <code>p_check_vsync_timings</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_3","title":"Description","text":"<p>This process verifies the VGA vertical synchronization (VSYNC) timing.</p> <p></p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_3","title":"Parameters","text":"<p>The process defines two variables:</p> Parameter Type Default Description <code>v_start_time</code> <code>time</code> - The start time of the measurement <code>v_start_bit_time</code> <code>time</code> - The start time of the measurement of a bit state"},{"location":"modules/testbench/tb_top_fpga/#steps_3","title":"Steps","text":"<ol> <li> <p>Wait for the start of HSYNC timings check</p> <ul> <li>Wait for a rising edge on signal <code>tb_check_vsync_timings</code></li> </ul> </li> <li> <p>Measure HSYNC pulse width (sync pulse duration)</p> <ul> <li>Wait for falling edge on <code>tb_pad_o_vga_vsync</code> (start of sync pulse)</li> <li>Capture both <code>v_start_time</code> and <code>v_start_bit_time</code> as baseline</li> <li>Wait for rising edge on <code>tb_pad_o_vga_vsync</code> (end of sync pulse)</li> <li>Validate sync pulse duration against <code>C_V_SYNC_PULSE_TIME</code> \u00b1 <code>C_V_SYNC_PULSE_TIME_ACCURACY</code></li> <li>Update <code>v_start_bit_time</code> to current time</li> </ul> </li> <li> <p>Measure HSYNC high period and total line time</p> <ul> <li>Wait for next falling edge on <code>tb_pad_o_vga_vsync</code></li> <li>Validate high period:  Check time since last edge against <code>C_V_HSYNC_HIGH_TIME</code> \u00b1 <code>C_V_HSYNC_HIGH_TIME_ACCURACY</code></li> <li>Validate complete frame time: Check time since initial <code>v_start_time</code> against <code>C_V_WHOLE_LINE_TIME</code> \u00b1 <code>C_V_WHOLE_LINE_TIME_ACCURACY</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedures","title":"Procedures","text":""},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_check_time_in_range","title":"Procedure <code>proc_check_time_in_range</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_4","title":"Description","text":"<p>This procedure performs a range check to verify that <code>time_to_check</code> is within <code>expected_time \u00b1 accuracy</code>.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_4","title":"Parameters","text":"Parameter Type Default Description <code>time_to_check</code> <code>time</code> - The actual time value to be validated <code>expected_time</code> <code>time</code> - The target/expected time value <code>accuracy</code> <code>time</code> - The acceptable deviation (tolerance) from the expected time <code>message</code> <code>string</code> <code>\"\"</code> Optional custom message prefix for the assertion output"},{"location":"modules/testbench/tb_top_fpga/#steps_4","title":"Steps","text":"<ol> <li>Perform Range Check<ul> <li>Check that <code>abs(time_to_check - expected_time) &lt;= accuracy</code> with procedure <code>check</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_reset_dut","title":"Procedure <code>proc_reset_dut</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_5","title":"Description","text":"<p>This procedure puts all the testbench signals into a known state.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_5","title":"Parameters","text":"Parameter Type Default Description <code>c_clock_cycles</code> <code>positive</code> 50 Number of clock cycles to wait"},{"location":"modules/testbench/tb_top_fpga/#steps_5","title":"Steps","text":"<ol> <li> <p>Reset the DUT by Setting Input State to All Zeros</p> <ul> <li>Set <code>tb_pad_i_rst_h</code> to <code>1</code></li> <li>Set <code>tb_i_uart_select</code> to <code>0</code></li> <li>Set <code>tb_i_uart_rx_manual</code> to <code>0</code></li> <li>Set <code>tb_pad_i_switch_0</code> to <code>0</code></li> <li>Set <code>tb_pad_i_switch_1</code> to <code>0</code></li> <li>Set <code>tb_pad_i_switch_2</code> to <code>0</code></li> <li>Set <code>tb_i_read_address</code> to <code>0x00</code></li> <li>Set <code>tb_i_read_address_valid</code> to <code>0</code></li> <li>Set <code>tb_i_write_address</code> to <code>0x00</code></li> <li>Set <code>tb_i_write_data</code> to <code>0x0000</code></li> <li>Set <code>tb_i_write_valid</code> to <code>0</code></li> <li>Set <code>tb_check_uart_timings</code> to <code>0</code></li> <li>Set <code>tb_check_spi_timings</code> to <code>0</code></li> </ul> </li> <li> <p>Wait for the Specified Number of Clock Cycles</p> <ul> <li>Wait for <code>c_clock_cycles * C_CLK_PERIOD</code></li> </ul> </li> <li> <p>De-assert Reset</p> <ul> <li>Set <code>tb_pad_i_rst_h</code> to <code>0</code></li> </ul> </li> <li> <p>Wait for the DUT to Settle</p> <ul> <li>Wait for 5 ns</li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_send_byte","title":"Procedure <code>proc_uart_send_byte</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_6","title":"Description","text":"<p>This procedure sends a byte via UART using the manually driven line.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_6","title":"Parameters","text":"Parameter Type Default Description <code>uart_rx</code> <code>std_logic</code> - The UART line to drive <code>byte_to_send</code> <code>vector[7:0]</code> - The byte to send"},{"location":"modules/testbench/tb_top_fpga/#steps_6","title":"Steps","text":"<ol> <li> <p>Ensure the Manual UART is Selected</p> <ul> <li>If <code>tb_i_uart_select = 0</code>:<ul> <li>Set <code>tb_i_uart_select</code> to <code>1</code></li> <li>Wait for 200 ns</li> </ul> </li> </ul> </li> <li> <p>Send the Start Bit</p> <ul> <li>Set <code>uart_rx</code> to <code>0</code></li> <li>Wait for <code>C_UART_BIT_TIME</code></li> </ul> </li> <li> <p>Send the Data Bits (LSB to MSB)</p> <ul> <li>For <code>bit_idx</code> in <code>byte_to_send'low</code> to <code>byte_to_send'high</code>:<ul> <li>Set <code>uart_rx</code> to <code>byte_to_send(bit_idx)</code></li> <li>Wait for <code>C_UART_BIT_TIME</code></li> </ul> </li> </ul> </li> <li> <p>Send the Stop Bit</p> <ul> <li>Set <code>uart_rx</code> to <code>1</code></li> <li>Wait for 1. 1 \u00d7 <code>C_UART_BIT_TIME</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_write","title":"Procedure <code>proc_uart_write</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_7","title":"Description","text":"<p>This procedure writes a value to a specified UART register.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_7","title":"Parameters","text":"Parameter Type Default Description <code>reg</code> <code>t_reg</code> - The register to write to <code>value</code> <code>vector[15:0]</code> - The value to write to the register"},{"location":"modules/testbench/tb_top_fpga/#steps_7","title":"Steps","text":"<ol> <li> <p>Ensure the Model UART is Selected</p> <ul> <li>If <code>tb_i_uart_select = 1</code>:<ul> <li>Set <code>tb_i_uart_select</code> to <code>0</code></li> <li>Wait for 200 ns</li> </ul> </li> </ul> </li> <li> <p>Set Up the Write Operation</p> <ul> <li>Set <code>tb_i_write_address</code> to <code>reg.addr</code></li> <li>Set <code>tb_i_write_data</code> to <code>value</code></li> <li>Set <code>tb_i_write_valid</code> to <code>1</code></li> </ul> </li> <li> <p>Wait and De-assert the Valid Flag</p> <ul> <li>Wait for 200 ns</li> <li>Set <code>tb_i_write_valid</code> to <code>0</code></li> </ul> </li> <li> <p>Wait for the Write Operation to Complete</p> <ul> <li>Wait for 1.1 \u00d7 <code>C_UART_WRITE_CMD_TIME</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_read","title":"Procedure <code>proc_uart_read</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_8","title":"Description","text":"<p>This procedure reads a value from a specified UART register.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_8","title":"Parameters","text":"Parameter Type Default Description <code>reg</code> <code>t_reg</code> - The register to read from"},{"location":"modules/testbench/tb_top_fpga/#steps_8","title":"Steps","text":"<ol> <li> <p>Ensure the Model UART is Selected</p> <ul> <li>If <code>tb_i_uart_select = 1</code>:<ul> <li>Set <code>tb_i_uart_select</code> to <code>0</code></li> <li>Wait for 200 ns</li> </ul> </li> </ul> </li> <li> <p>Wait Before Starting the Read</p> <ul> <li>Wait for 500 ns (to avoid simulation stuck)</li> </ul> </li> <li> <p>Set Up the Read Operation</p> <ul> <li>Set <code>tb_i_read_address</code> to <code>reg.addr</code></li> <li>Set <code>tb_i_read_address_valid</code> to <code>1</code></li> </ul> </li> <li> <p>Wait for the Read Operation to Complete</p> <ul> <li>Wait for a rising edge on signal <code>tb_o_read_data_valid</code></li> </ul> </li> <li> <p>De-assert the Read Valid Signal</p> <ul> <li>Set <code>tb_i_read_address_valid</code> to <code>0</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_check","title":"Procedure <code>proc_uart_check</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_9","title":"Description","text":"<p>This procedure checks if the read value from a specified UART register matches the expected value.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_9","title":"Parameters","text":"Parameter Type Default Description <code>reg</code> <code>t_reg</code> - The register to check <code>expected_value</code> <code>vector[15:0]</code> - The expected value to compare against"},{"location":"modules/testbench/tb_top_fpga/#steps_9","title":"Steps","text":"<ol> <li> <p>Read the Register Value</p> <ul> <li>Read the register <code>reg</code> value with procedure <code>proc_uart_read</code></li> </ul> </li> <li> <p>Check the Returned Value</p> <ul> <li>Check that the returned value <code>tb_o_read_data</code> equals <code>expected_value</code> with the procedure <code>check_equal</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_check_default_value","title":"Procedure <code>proc_uart_check_default_value</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_10","title":"Description","text":"<p>This procedure checks if the default value of a specified UART register matches the expected reset value.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_10","title":"Parameters","text":"Parameter Type Default Description <code>reg</code> <code>t_reg</code> - The register to check"},{"location":"modules/testbench/tb_top_fpga/#steps_10","title":"Steps","text":"<ol> <li>Check the Default Value Against the Register's Reset Value<ul> <li>Check that the value after reset is equal to the one specified in <code>reg.data</code> with the procedure <code>proc_uart_check</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_check_read_only","title":"Procedure <code>proc_uart_check_read_only</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_11","title":"Description","text":"<p>This procedure checks if a specified UART register is read-only by attempting to write to it and verifying that the value remains unchanged.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_11","title":"Parameters","text":"Parameter Type Default Description <code>reg</code> <code>t_reg</code> - The register to check"},{"location":"modules/testbench/tb_top_fpga/#steps_11","title":"Steps","text":"<ol> <li> <p>Attempt to Write an Incorrect Value to the Register</p> <ul> <li>Write the data <code>not(reg.data)</code> to the register address <code>reg.addr</code> with procedure <code>proc_uart_write</code></li> </ul> </li> <li> <p>Check if the Register Value Remains Unchanged</p> <ul> <li>Read back the register and check if the register value remains unchanged with procedure <code>proc_uart_check</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_uart_check_read_write","title":"Procedure <code>proc_uart_check_read_write</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_12","title":"Description","text":"<p>This procedure checks if a specified UART register is read-write by writing a value to it and verifying that the value is correctly updated.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_12","title":"Parameters","text":"Parameter Type Default Description <code>reg</code> <code>t_reg</code> - The register to check <code>expected_value</code> <code>vector[15:0]</code> - The expected value to compare against after writing"},{"location":"modules/testbench/tb_top_fpga/#steps_12","title":"Steps","text":"<ol> <li> <p>Write the Inverted Default Value to the Register</p> <ul> <li>Write the data <code>not(reg.data)</code> to the register address <code>reg.addr</code> with procedure <code>proc_uart_write</code></li> </ul> </li> <li> <p>Check if the Register Value is Updated Correctly</p> <ul> <li>Read back the register and check if the register value is matching <code>expected_value</code> with procedure <code>proc_uart_check</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_spi_write","title":"Procedure <code>proc_spi_write</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_13","title":"Description","text":"<p>Writes a byte value to the SPI master module via UART register interface.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_13","title":"Parameters","text":"Parameter Type Default Description <code>value</code> <code>vector[7:0]</code> - 8-bit data to transmit via SPI"},{"location":"modules/testbench/tb_top_fpga/#steps_13","title":"Steps","text":"<ol> <li> <p>Reset C_REG_SPI_TX for Rising Edge Detection</p> <ul> <li>Write <code>0x0000</code> to register <code>C_REG_SPI_TX</code> with procedure <code>proc_uart_write</code></li> </ul> </li> <li> <p>Write the Data with Valid Flag Set</p> <ul> <li>Write <code>(7b0 &amp; 1b1 &amp; value)</code> to the register <code>C_REG_SPI_TX</code> with procedure <code>proc_uart_write</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/tb_top_fpga/#procedure-proc_spi_check","title":"Procedure <code>proc_spi_check</code>","text":""},{"location":"modules/testbench/tb_top_fpga/#description_14","title":"Description","text":"<p>Writes a value to SPI master and verifies correct transmission and reception.</p>"},{"location":"modules/testbench/tb_top_fpga/#parameters_14","title":"Parameters","text":"Parameter Type Default Description <code>value</code> <code>vector[7:0]</code> - 8-bit data to transmit and verify"},{"location":"modules/testbench/tb_top_fpga/#steps_14","title":"Steps","text":"<ol> <li> <p>Write Data to SPI</p> <ul> <li>Start an SPI transaction with procedure <code>proc_spi_write</code></li> </ul> </li> <li> <p>Retrieve Data from SPI Slave Stream</p> <ul> <li>Pop data from <code>C_SLAVE_STREAM</code> into <code>v_spi_slave_data</code> (MOSI path verification)</li> </ul> </li> <li> <p>Verify MOSI Path</p> <ul> <li>Check that <code>v_spi_slave_data</code> equals <code>value</code> with procedure <code>check_equal</code></li> </ul> </li> <li> <p>Read and Verify MISO Register Data</p> <ul> <li>Check that sampled SPI data from slave is matching the one decoded in the <code>REG_SPI_RX</code> register with procedure <code>proc_uart_check</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/testcases/","title":"Testcase Descriptions","text":""},{"location":"modules/testbench/testcases/#testcase-01-test_top_fpga_registers","title":"Testcase 01: <code>test_top_fpga_registers</code>","text":""},{"location":"modules/testbench/testcases/#description","title":"Description","text":"<p>Checks default values and access rights (RO/RW) for the test registers of the FPGA.</p>"},{"location":"modules/testbench/testcases/#steps","title":"Steps","text":"<ol> <li> <p>Reset the DUT</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> </ul> </li> <li> <p>Check Default Register Values</p> <ul> <li>For each register:<ul> <li><code>C_REG_GIT_ID_MSB</code></li> <li><code>C_REG_GIT_ID_LSB</code></li> <li><code>C_REG_12</code></li> <li><code>C_REG_34</code></li> <li><code>C_REG_56</code></li> <li><code>C_REG_78</code></li> <li><code>C_REG_9A</code></li> <li><code>C_REG_CD</code></li> <li><code>C_REG_EF</code></li> <li><code>C_REG_16_BITS</code></li> <li><code>C_REG_DEAD</code></li> </ul> </li> </ul> <p>Call <code>proc_uart_check_default_value</code> and verify value   after reset.</p> </li> <li> <p>Verify Read-Only Registers</p> <ul> <li>For each read-only register (same as above except for <code>C_REG_16_BITS</code>):</li> <li>Call <code>proc_uart_check_read_only</code>.</li> </ul> </li> <li> <p>Verify Read-Write Registers</p> <ul> <li>Check <code>C_REG_16_BITS</code>:<ul> <li>Write <code>not C_REG_16_BITS.data</code> with <code>proc_uart_write</code>.</li> <li>Read back and verify value with <code>proc_uart_check</code>.</li> </ul> </li> </ul> </li> <li> <p>Write and Verify Custom Value</p> <ul> <li>Write <code>0xABCD</code> to <code>C_REG_16_BITS</code>.</li> <li>Read back and check value is <code>0xABCD</code>.</li> </ul> </li> </ol>"},{"location":"modules/testbench/testcases/#testcase-02-test_uart_robustness","title":"Testcase 02: <code>test_uart_robustness</code>","text":""},{"location":"modules/testbench/testcases/#description_1","title":"Description","text":"<p>Tests robustness of UART implementation including invalid start/stop bits and command framing.</p>"},{"location":"modules/testbench/testcases/#steps_1","title":"Steps","text":"<ol> <li> <p>Reset the DUT</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> </ul> </li> <li> <p>Send Read Command With Invalid Start Bit in 'R'</p> <ul> <li>Set manual UART: <code>tb_i_uart_select</code> to <code>1</code></li> <li>Manipulate <code>tb_i_uart_rx_manual</code> as follows:<ol> <li>Set to <code>0</code>, wait 0.25 \u00d7 <code>C_UART_BIT_TIME</code> (invalid start bit)</li> <li>Set to <code>1</code>, wait 0.75 \u00d7 <code>C_UART_BIT_TIME</code></li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 0)</li> <li>Set to <code>1</code>, wait <code>C_UART_BIT_TIME</code> (bit 1)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 2)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 3)</li> <li>Set to <code>1</code>, wait <code>C_UART_BIT_TIME</code> (bit 4)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 5)</li> <li>Set to <code>1</code>, wait <code>C_UART_BIT_TIME</code> (bit 6)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 7)</li> <li>Send stop bit (<code>1</code>), 1.1 \u00d7 wait <code>C_UART_BIT_TIME</code></li> </ol> </li> <li>Send bytes <code>0x30</code>, <code>0x30</code>, <code>0x0D</code> using <code>proc_uart_send_byte</code></li> <li>Wait 1.1 \u00d7 <code>C_UART_READ_CMD_TIME</code></li> <li>Check UART TX is stable high: <code>tb_pad_o_uart_tx</code> remains <code>1</code> for <code>C_UART_READ_CMD_TIME</code> with <code>check_equal</code></li> </ul> </li> <li> <p>Send Read Command With Invalid Stop Bit in 'R'</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Set <code>tb_i_uart_select</code> to <code>1</code></li> <li>Manipulate <code>tb_i_uart_rx_manual</code> as follows:<ol> <li>Send start bit (<code>0</code>), wait <code>C_UART_BIT_TIME</code></li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 0)</li> <li>Set to <code>1</code>, wait <code>C_UART_BIT_TIME</code> (bit 1)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 2)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 3)</li> <li>Set to <code>1</code>, wait <code>C_UART_BIT_TIME</code> (bit 4)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 5)</li> <li>Set to <code>1</code>, wait <code>C_UART_BIT_TIME</code> (bit 6)</li> <li>Set to <code>0</code>, wait <code>C_UART_BIT_TIME</code> (bit 7)</li> <li>Send invalid stop bit (<code>0</code>), 1.1 \u00d7 wait <code>C_UART_BIT_TIME</code></li> </ol> </li> <li>Send bytes <code>0x30</code>, <code>0x30</code>, <code>0x0D</code> using <code>proc_uart_send_byte</code></li> <li>Wait 1.1 \u00d7 <code>C_UART_READ_CMD_TIME</code></li> <li>Check UART TX is stable high: <code>tb_pad_o_uart_tx</code> remains <code>1</code> for <code>C_UART_READ_CMD_TIME</code> with <code>check_equal</code></li> </ul> </li> <li> <p>Check UART Timings With Value <code>0x5555</code></p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Set <code>tb_check_uart_timings</code> to <code>1</code></li> <li>Write <code>0x5555</code> to <code>C_REG_16_BITS</code> with <code>proc_uart_write</code></li> <li>Read back using <code>proc_uart_read</code> to start the timing check</li> <li>Wait for <code>C_UART_READ_CMD_TIME</code></li> </ul> </li> <li> <p>Send Read Commands With Invalid CR</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Send bytes: <code>0x52</code>, <code>0x30</code>, <code>0x31</code>, <code>0x0A</code> (missing CR)</li> <li>Wait <code>C_UART_READ_CMD_TIME</code></li> <li>Check TX remains <code>1</code> for duration</li> </ul> </li> <li> <p>Send Write Command With Invalid CR</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Check default value for <code>C_REG_16_BITS</code></li> <li>Send bytes: <code>0x57</code>, <code>0x46</code>, <code>0x46</code>, <code>0x39</code>, <code>0x40</code>, <code>0x41</code>, <code>0x42</code>, <code>0x0A</code> using <code>proc_uart_send_byte</code></li> <li>Wait <code>C_UART_READ_CMD_TIME</code></li> <li>Check value in <code>C_REG_16_BITS</code> was not written; contents unchanged with <code>proc_uart_check</code></li> </ul> </li> </ol>"},{"location":"modules/testbench/testcases/#testcase-03-test_led_and_switches_toggling","title":"Testcase 03: <code>test_led_and_switches_toggling</code>","text":""},{"location":"modules/testbench/testcases/#description_2","title":"Description","text":"<p>Validates <code>REG_LED</code> (read-write) and <code>REG_SWITCHES</code> (read-only). Checks toggling the LED output and reading all switch combinations.</p>"},{"location":"modules/testbench/testcases/#steps_2","title":"Steps","text":"<ol> <li> <p>Check Register <code>REG_LED</code> Characteristics</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Check default value using <code>proc_uart_check_default_value</code> for <code>C_REG_LED</code></li> <li>Check register <code>C_REG_LED</code> is in read-write mode by writing <code>not C_REG_LED.data</code> and that written value equals to <code>15b\"0\" &amp; not C_REG_LED.data(0)</code> using <code>proc_uart_check_read_write</code></li> </ul> </li> <li> <p>Toggle <code>led_0</code> Register and Verify Output</p> <ul> <li>Write <code>0x0001</code> to <code>C_REG_LED</code>   Wait for 1 ms   Check <code>tb_pad_o_led_0</code> is stable at <code>'1'</code> for <code>0.7 ms</code> using <code>check_equal</code></li> <li>Write <code>0x0000</code> to <code>C_REG_LED</code>   Wait for 2.5 ms   Check <code>tb_pad_o_led_0</code> is stable at <code>'0'</code> for <code>2.3 ms</code></li> <li>Write <code>0x0001</code> to <code>C_REG_LED</code>   Wait for 2 ms   Check <code>tb_pad_o_led_0</code> is stable at <code>'1'</code> for <code>1.8 ms</code></li> </ul> </li> <li> <p>Check Register <code>REG_SWITCHES</code> Characteristics</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Check default value using <code>proc_uart_check_default_value</code>  for <code>C_REG_SWITCHES</code></li> <li>Check register <code>C_REG_SWITCHES</code> is in read-only mode using <code>proc_uart_check_read_only</code></li> </ul> </li> <li> <p>Toggle Input Switches and Verify Combinations</p> <ul> <li>For all combinations of <code>tb_pad_i_switch_0</code>, <code>tb_pad_i_switch_1</code>, <code>tb_pad_i_switch_2</code> (from <code>0</code> to <code>7</code>):<ul> <li>Set switches with binary pattern from <code>i</code></li> <li>Wait for 1 ns (signal propagation)</li> <li>Check register <code>C_REG_SWITCHES</code> value matches the bit pattern using <code>proc_uart_check</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"modules/testbench/testcases/#testcase-04-test_spi","title":"Testcase 04: <code>test_spi</code>","text":""},{"location":"modules/testbench/testcases/#description_3","title":"Description","text":"<p>Tests SPI master TX and RX registers, including SPI transfer correctness and MOSI/MISO data verification.</p>"},{"location":"modules/testbench/testcases/#steps_3","title":"Steps","text":"<ol> <li> <p>Reset DUT and Check Register Default Values</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Check default value of <code>C_REG_SPI_TX</code> using <code>proc_uart_check_default_value</code></li> <li>Check default value of <code>C_REG_SPI_RX</code> using <code>proc_uart_check_default_value</code></li> <li>Check register <code>C_REG_SPI_RX</code> is in read-only mode using <code>proc_uart_check_read_only</code></li> <li>Check register <code>C_REG_SPI_TX</code> is in read-write mode by writing <code>not C_REG_SPI_TX.data</code> and that written value equals to <code>0x01FF</code> using <code>proc_uart_check_read_write</code></li> <li>Pop data from SPI model and check it is equals to <code>not C_REG_SPI_TX.data[7:0]</code> with <code>check_equal</code></li> </ul> </li> <li> <p>Testing SPI output</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Send an SPI transaction with data set to <code>0x55</code> using <code>proc_spi_check</code></li> <li>Send an SPI transaction with data set to <code>0xAB</code> using <code>proc_spi_check</code></li> <li>Send an SPI transaction with data set to <code>0x1E</code> using <code>proc_spi_check</code></li> </ul> </li> <li> <p>Testing SPI timings</p> <ul> <li>Call <code>proc_reset_dut</code></li> <li>Wait for 100 \u00b5s</li> <li>Set <code>tb_check_spi_timings</code> to 1</li> <li>Wait for 2 \u00d7 <code>C_CLK_PERIOD</code></li> <li>Set <code>tb_check_spi_timings</code> to 0</li> <li>Send an SPI transaction with data set to <code>0x55</code> using <code>proc_spi_write</code></li> <li>Wait for 2 \u00d7 <code>C_SPI_TRANSACTION_TIME</code> (time longer than the response)</li> <li>Set <code>tb_check_spi_timings</code> to 1</li> <li>Wait for 2 \u00d7 <code>C_CLK_PERIOD</code></li> <li>Set <code>tb_check_spi_timings</code> to 0</li> <li>Send an SPI transaction with data set to <code>0xAB</code> using <code>proc_spi_write</code></li> <li>Wait for 2 \u00d7 <code>C_SPI_TRANSACTION_TIME</code> (time longer than the response)</li> </ul> </li> </ol>"},{"location":"modules/uart/uart/","title":"UART","text":""},{"location":"modules/uart/uart/#description","title":"Description","text":""},{"location":"modules/uart/uart/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps <code>G_SAMPLING_RATE</code> positive 0d16 Sampling rate (number of clock cycles per bit)"},{"location":"modules/uart/uart/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_P</code> std_logic in - Input asynchronous reset, active low <code>I_UART_RX</code> std_logic in - Asynchronous input UART RX line <code>O_UART_TX</code> std_logic out 0b1 Output UART TX line <code>O_READ_ADDR</code> vector[7:0] out 0x00 Output read address <code>O_READ_ADDR_VALID</code> std_logic out 0b0 Output read address valid flag <code>I_READ_DATA</code> vector[15:0] in - Input read data <code>I_READ_DATA_ADDR_VALID</code> std_logic in - Input read data valid <code>O_WRITE_ADDR</code> vector[7:0] out 0x00 Output write address <code>O_WRITE_DATA</code> vector[15:0] out 0x0000 Output write data <code>O_WRITE_VALID</code> std_logic out 0b0 Output write valid flag"},{"location":"modules/uart/uart/#architecture","title":"Architecture","text":""},{"location":"modules/uart/uart/#sub-modules","title":"Sub-modules","text":"<p>The UART controller module instantiates the UART RX module with the following generics:</p> Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive <code>G_CLK_FREQ_HZ</code> Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive <code>G_BAUD_RATE_BPS</code> Baud rate in bps <code>G_SAMPLING_RATE</code> positive <code>G_SAMPLING_RATE</code> Sampling rate (number of clock cycles per bit) <p>The UART controller module instantiates the UART TX module with the following generics:</p> Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive <code>G_CLK_FREQ_HZ</code> Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive <code>G_BAUD_RATE_BPS</code> Baud rate in bps"},{"location":"modules/uart/uart/#about","title":"About","text":""},{"location":"modules/uart/uart/#protocol","title":"Protocol","text":"<p>The implemented UART protocol is an ASCII-based protocol to access the internal registers of the FPGA. All commands and responses are ASCII text and every message is terminated by a mandatory carriage-return (CR, <code>\\r</code>). A line-feed (LF, <code>\\n</code>) may follow CR but is optional and ignored by the device.</p> <p>The following fields are defined:</p> <ul> <li><code>AA</code>: 8-bit address (two ASCII hex characters)</li> <li><code>DDDD</code>: 16-bit data (four ASCII hex characters)</li> </ul> <p></p>"},{"location":"modules/uart/uart/#read-mode","title":"Read Mode","text":"<p>The read mode allows reading a 16-bit value from a specified 8-bit register address. The device responds with the current register value.</p> <p>Command Format:</p> <pre><code>R + AA + \\r[\\n]\n</code></pre> <ul> <li><code>R</code>: literal ASCII 'R' (read command)</li> <li><code>AA</code>: two ASCII hex characters representing an 8-bit address (<code>00</code> .. <code>FF</code>)</li> <li><code>\\r</code>: mandatory CR terminator (ASCII 0x0D)</li> <li><code>\\n</code>: optional LF (ASCII 0x0A), if present it is ignored by the device</li> </ul> <p>Response Format:</p> <pre><code>DDDD + \\r[\\n]\n</code></pre> <ul> <li><code>DDDD</code>: four ASCII hex characters representing the 16-bit register value, MSB first (<code>0000</code> .. <code>FFFF</code>)</li> <li><code>\\r</code>: mandatory CR terminator</li> <li><code>\\n</code>: optional LF (ASCII 0x0A)</li> </ul> <p>Examples:</p> <pre><code># Read address 0x1A\nSent                   : R1A\\r\\n\nBytes transmitted (hex): 0x52 0x31 0x41 0x0D 0x0A\nReply                  : 0F3C\\r\nBytes received    (hex): 0x30 0x46 0x33 0x43 0x0D\n</code></pre> <pre><code># Read address 0xFF\nSent                   : RFF\\r\nBytes transmitted (hex): 0x52 0x46 0x46 0x0D\nReply                  : DEAD\\r\nBytes received    (hex): 0x44 0x45 0x39 0x44 0x0D\n</code></pre>"},{"location":"modules/uart/uart/#write-mode","title":"Write Mode","text":"<p>The write mode allows writing a 16-bit value to a specified 8-bit register address. The device does not send any acknowledgment response after a successful write operation.</p> <p>Command Format:</p> <pre><code>W + AA + DDDD + \\r[\\n]\n</code></pre> <ul> <li><code>W</code>: literal ASCII 'W' (write command)</li> <li><code>AA</code>: two ASCII hex characters representing an 8-bit address (<code>00</code> .. <code>FF</code>)</li> <li><code>DDDD</code>: four ASCII hex characters representing the 16-bit data value to write, MSB first (<code>0000</code> .. <code>FFFF</code>)</li> <li><code>\\r</code>: mandatory CR terminator (ASCII 0x0D)</li> <li><code>\\n</code>: optional LF (ASCII 0x0A), if present it is ignored by the device</li> </ul> <p>Response Format:</p> <p>No response is expected or generated by the device for write commands.</p> <p>Important</p> <p>To verify that data was correctly written to the given address, perform a read-back operation using the read command on the same register address.</p> <p>Example:</p> <pre><code># Write value 0x1234 to address 0x1A\nSent                   : W1A1234\\r\\n\nBytes transmitted (hex): 0x57 0x31 0x41 0x31 0x32 0x33 0x34 0x0D 0x0A\nReply                  : (no reply expected)\n</code></pre> <pre><code># Write value 0x0001 to address 0x01\nSent                   : W010001\\r\nBytes transmitted (hex): 0x57 0x30 0x31 0x30 0x30 0x30 0x31 0x0D\nReply                  : (no reply expected)\n</code></pre>"},{"location":"modules/uart/uart/#special-behavior","title":"Special behavior","text":"<p>Some transitions have special behavior: at every character received, the FSM checks if it is an <code>R</code> or <code>W</code> character. If detected, the FSM immediately abandons any ongoing operation and starts processing the new command.</p> <p>This means that a new read or write command can interrupt and completely override a partially received command, even if the previous command was not yet complete.</p> <p>Example: Interrupted Write Command</p> <pre><code># Sending the following ASCII characters: W001R00\\r\n#                                             \u2191\n#                              Sudden change to read command,\n#                              even though write command was incomplete\nSent       : W001R00\\r\nExpected   : Write incomplete data to address 0x00\nActual     : Read from address 0x00\nResult     : Returns the data at address 0x00\n             No write operation is performed\n</code></pre>"},{"location":"modules/uart/uart/#fsm","title":"FSM","text":"<p>The UART FSM handling the above protocol is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>rst_soft_p = 1</code> T1 <code>rx_byte = W character</code> T2 <code>rx_byte /= CR (\\r) character</code> AND <code>rx_byte_count &gt;= 3</code> T3 <code>rx_byte = CR (\\r) character</code> AND <code>rx_byte_count &gt;= 3</code> T4 Automatic T5 <code>rx_byte = R character</code> T6 <code>rx_byte /= CR (\\r) character</code> AND <code>rx_byte_count &gt;= 7</code> T7 <code>rx_byte = CR (\\r) character</code> AND <code>rx_byte_count &gt;= 7</code> T8 Automatic T9 <code>I_READ_DATA_VALID = 1</code> T10 <code>tx_byte_count &gt;= 5</code>"},{"location":"modules/uart/uart/#data-decoding","title":"Data decoding","text":"<p>The received data needs to be decoded from ASCII to hexadecimal to be usable in the registers. To do so, the signal <code>rx_byte_decoded</code> receives:</p>"},{"location":"modules/uart/uart/#ascii-to-hexadecimal-decoding","title":"ASCII to Hexadecimal Decoding","text":"Decoded Value ASCII Character Condition <code>0x0</code> '0' <code>rx_byte = 0x30</code> <code>0x1</code> '1' <code>rx_byte = 0x31</code> <code>0x2</code> '2' <code>rx_byte = 0x32</code> <code>0x3</code> '3' <code>rx_byte = 0x33</code> <code>0x4</code> '4' <code>rx_byte = 0x34</code> <code>0x5</code> '5' <code>rx_byte = 0x35</code> <code>0x6</code> '6' <code>rx_byte = 0x36</code> <code>0x7</code> '7' <code>rx_byte = 0x37</code> <code>0x8</code> '8' <code>rx_byte = 0x38</code> <code>0x9</code> '9' <code>rx_byte = 0x39</code> <code>0xA</code> 'A' <code>rx_byte = 0x41</code> <code>0xB</code> 'B' <code>rx_byte = 0x42</code> <code>0xC</code> 'C' <code>rx_byte = 0x43</code> <code>0xD</code> 'D' <code>rx_byte = 0x44</code> <code>0xE</code> 'E' <code>rx_byte = 0x45</code> <code>0xF</code> 'F' <code>rx_byte = 0x46</code>"},{"location":"modules/uart/uart/#decoding-special-characters","title":"Decoding Special Characters","text":"Character ASCII Value Condition Default/Invalid <code>0x00</code> No match found"},{"location":"modules/uart/uart/#data-encoding","title":"Data encoding","text":"<p>The transmit data needs to be encoded from hexadecimal to ASCII before being sent over UART. To do so, the signal <code>tx_byte_to_send_encoded</code> receives:</p>"},{"location":"modules/uart/uart/#hexadecimal-to-ascii-encoding","title":"Hexadecimal to ASCII Encoding","text":"Input Value ASCII Character Encoded Value <code>0x0</code> '0' <code>tx_byte_to_send_encoded = 0x30</code> <code>0x1</code> '1' <code>tx_byte_to_send_encoded = 0x31</code> <code>0x2</code> '2' <code>tx_byte_to_send_encoded = 0x32</code> <code>0x3</code> '3' <code>tx_byte_to_send_encoded = 0x33</code> <code>0x4</code> '4' <code>tx_byte_to_send_encoded = 0x34</code> <code>0x5</code> '5' <code>tx_byte_to_send_encoded = 0x35</code> <code>0x6</code> '6' <code>tx_byte_to_send_encoded = 0x36</code> <code>0x7</code> '7' <code>tx_byte_to_send_encoded = 0x37</code> <code>0x8</code> '8' <code>tx_byte_to_send_encoded = 0x38</code> <code>0x9</code> '9' <code>tx_byte_to_send_encoded = 0x39</code> <code>0xA</code> 'A' <code>tx_byte_to_send_encoded = 0x41</code> <code>0xB</code> 'B' <code>tx_byte_to_send_encoded = 0x42</code> <code>0xC</code> 'C' <code>tx_byte_to_send_encoded = 0x43</code> <code>0xD</code> 'D' <code>tx_byte_to_send_encoded = 0x44</code> <code>0xE</code> 'E' <code>tx_byte_to_send_encoded = 0x45</code> <code>0xF</code> 'F' <code>tx_byte_to_send_encoded = 0x46</code>"},{"location":"modules/uart/uart/#encoding-special-characters","title":"Encoding Special Characters","text":"Character ASCII Value Condition Carriage Return (CR) <code>0x0D</code> <code>tx_byte_count = C_TX_DATA_BYTES</code> Default/Invalid <code>0x00</code> No match found"},{"location":"modules/uart/uart_rx/","title":"UART RX","text":""},{"location":"modules/uart/uart_rx/#description","title":"Description","text":""},{"location":"modules/uart/uart_rx/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps <code>G_SAMPLING_RATE</code> positive 0d16 Sampling rate (number of clock cycles per bit)"},{"location":"modules/uart/uart_rx/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_P</code> std_logic in - Input asynchronous reset, active low <code>I_UART_RX</code> std_logic in - Asynchronous input UART RX line <code>O_BYTE</code> vector[7:0] out 0x00 Output byte <code>O_BYTE_VALID</code> std_logic out 0b0 Output byte valid flag <code>O_START_BIT_ERROR</code> std_logic out 0b0 Output start bit error flag <code>O_STOP_BIT_ERROR</code> std_logic out 0b0 Output stop bit error flag"},{"location":"modules/uart/uart_rx/#architecture","title":"Architecture","text":"<p>The UART receiver must synchronize to incoming data, sample at the correct time, handle noise, and detect framing errors. The receiver uses oversampling, digital filtering, and majority voting to ensure reliable data reception.</p> <p></p>"},{"location":"modules/uart/uart_rx/#oversampling-clock","title":"Oversampling Clock","text":"<p>The receiver generates an internal sampling clock that runs at a multiple of the baud rate (configured by <code>G_SAMPLING_RATE</code>,  typically 16).</p> <p>The oversampling clock divider generates a tick (<code>rx_baud_tick</code>) at the oversampling rate. For example, with 16\u00d7 oversampling and 115200 baud:</p> \\[ f_{oversample} = 115200 \\times 16 = 1.8432\\mathrm{ MHz} \\] <p>The clock divider is enabled during active reception and reset during idle to ensure proper synchronization with incoming data.</p> <p>Note</p> <p>The oversampling rate is configurable via the <code>G_SAMPLING_RATE</code> generic. A higher rate provides better noise  immunity but requires a faster system clock.</p>"},{"location":"modules/uart/uart_rx/#input-synchronization-and-filtering","title":"Input Synchronization and Filtering","text":"<p>The asynchronous UART RX input must be properly synchronized to prevent metastability and filtered to remove noise.</p>"},{"location":"modules/uart/uart_rx/#synchronization-chain","title":"Synchronization Chain","text":"<p>A 5-stage shift register processes the incoming signal:</p> <pre><code>Stage 0-1: Metastability resolution (2 flip-flops)\nStage 2-4: Digital filtering (3 consecutive samples)\nI_UART_RX \u2192 [FF] \u2192 [FF] \u2192 [Filter] \u2192 [Filter] \u2192 [Filter] \u2192 i_uart_rx_filtered\n</code></pre>"},{"location":"modules/uart/uart_rx/#digital-filtering-logic","title":"Digital Filtering Logic","text":"<p>The filter uses a simple majority voting algorithm on the last 3 stages:</p> Input Samples (bits 4:2) Filtered Output Description <code>000</code> <code>0</code> All zeros \u2192 output low <code>111</code> <code>1</code> All ones \u2192 output high Other patterns Keep previous value Insufficient agreement <p>Important</p> <p>The first 2 bits of the shift register are potentially metastable and must NOT be used for any logic decisions. Only bits [4:2] are used for filtering. (I made this mistake)</p>"},{"location":"modules/uart/uart_rx/#edge-detection","title":"Edge Detection","text":"<p>A delayed version of the filtered signal (<code>i_uart_rx_filtered_d1</code>) is maintained to detect edges:</p> <ul> <li>Falling edge (<code>1</code> \u2192 <code>0</code>): Indicates start bit detection</li> <li>Rising edge (<code>0</code> \u2192 <code>1</code>): Used for stop bit validation</li> </ul>"},{"location":"modules/uart/uart_rx/#oversampling-and-bit-timing","title":"Oversampling and Bit Timing","text":"<p>Each UART bit period is divided into multiple sampling intervals. With 16\u00d7 oversampling, each bit period contains 16 ticks.</p>"},{"location":"modules/uart/uart_rx/#tick-counting","title":"Tick Counting","text":"<p>The <code>oversampling_counter</code> counter tracks the position within the current bit period:</p> <ul> <li>Increments on each <code>rx_baud_tick</code></li> <li>Resets to 0 after reaching <code>C_OVERSAMPLE_MAX</code> (15 for 16\u00d7 oversampling)</li> <li>When it wraps, one complete bit period has elapsed</li> </ul>"},{"location":"modules/uart/uart_rx/#visual-timing-diagram","title":"Visual Timing Diagram","text":"<pre><code>Idle/Previous Bit                           Current Data Bit                           Next Bit\n     (High)                                     (Low)                                   (High)\n________________                                                                 __________________\n                \\                                                               /\n                 \\                                                             /\n                  \\                                                           /\n                   \\_________________________________________________________/\nTick:                 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15\nSamples:                                      ^\n                                       Sample Point\nLegend:\n- 16 ticks per bit period (numbered 0-15)\n- Samples taken at tick\n- Provides maximum timing margin from bit edges\n</code></pre>"},{"location":"modules/uart/uart_rx/#sample-point-selection","title":"Sample Point Selection","text":"<p>The mid-bit sample point is calculated as:</p> \\[ \\mathrm{mid bit} = \\frac{\\mathrm{G}\\_\\mathrm{BAUD}\\_\\mathrm{RATE}\\_\\mathrm{BPS} - 1}{2} \\]"},{"location":"modules/uart/uart_rx/#bit-counter","title":"Bit Counter","text":"<p>The <code>bit_counter</code> counter tracks how many data bits have been received.</p>"},{"location":"modules/uart/uart_rx/#data-shift-register","title":"Data Shift Register","text":"<p>The <code>next_o_byte</code> register accumulates the incoming data bits.</p>"},{"location":"modules/uart/uart_rx/#shifting-operation","title":"Shifting Operation","text":"<p>Data is received MSB first (UART standard). Each new bit is shifted in from the left:</p> <pre><code>next_o_byte &lt;= uart_rx_sampled_bit &amp; next_o_byte(7 downto 1);\n</code></pre>"},{"location":"modules/uart/uart_rx/#example-reception-sequence","title":"Example Reception Sequence","text":"<p>Receiving byte <code>0x5A</code> (<code>0b01011010</code>):</p> <pre><code>Initial:      next_o_byte = xxxxxxxx\nBit 0 (D0=0): next_o_byte = 0xxxxxxx  (shift in 0)\nBit 1 (D1=1): next_o_byte = 10xxxxxx  (shift in 1)\nBit 2 (D2=0): next_o_byte = 010xxxxx  (shift in 0)\nBit 3 (D3=1): next_o_byte = 1010xxxx  (shift in 1)\nBit 4 (D4=1): next_o_byte = 11010xxx  (shift in 1)\nBit 5 (D5=0): next_o_byte = 011010xx  (shift in 0)\nBit 6 (D6=1): next_o_byte = 1011010x  (shift in 1)\nBit 7 (D7=0): next_o_byte = 01011010  (shift in 0)\nFinal:        next_o_byte = 0x5A \u2713\n</code></pre> <p>The byte is complete after 8 bits and ready to be latched to the output if the stop bit is valid.</p>"},{"location":"modules/uart/uart_rx/#error-recovery-mechanism","title":"Error Recovery Mechanism","text":"<p>When an invalid start bit is detected, the module enters an error recovery state to prevent false triggering on glitches or noise.</p> <p>The module then waits for the following time before going back to idle and accept new RX requests:</p> \\[ \\mathrm{RECOVERY}\\_\\mathrm{PERIOD} = \\mathrm{G}\\_\\mathrm{SAMPLING}\\_\\mathrm{RATE} \\times (\\mathrm{G}\\_\\mathrm{NB}\\_\\mathrm{DATA}\\_\\mathrm{BITS} + 1) \\] <p>This represents the time for almost one complete UART frame (data bits + stop bit) at the configured baud rate.</p>"},{"location":"modules/uart/uart_rx/#fsm","title":"FSM","text":"<p>The UART RX FSM is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>i_uart_rx_filtered_d1 = 1</code> AND <code>i_uart_rx_filtered = 0</code> (falling edge on the UART line) T1 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = G_SAMPLING_RATE - 1</code> AND <code>uart_rx_sampled_bit = 1</code> (invalid start bit = 1) T2 Automatic T3 <code>recovery_elapsed = 1</code> T4 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = G_SAMPLING_RATE - 1</code> AND <code>uart_rx_sampled_bit = 0</code> (valid start bit = 0) T5 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = G_SAMPLING_RATE - 1</code> AND <code>bit_counter = O_BYTE'length - 1</code> T6 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = C_THREE_QUARTER_POINT - 1</code> AND <code>uart_rx_sampled_bit = 0</code> (invalid stop bit = 0) T7 Automatic T8 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = C_THREE_QUARTER_POINT - 1</code> AND <code>uart_rx_sampled_bit = 1</code> (valid stop bit = 1) T9 Automatic <p>Note</p> <p>Early Stop Bit Exit for Burst Support The module exits the stop bit at 3/4 of the bit period (tick 12 of 16) after validation at mid-point (tick 8).This enables zero-gap back-to-back frame reception for burst transmissions.</p>"},{"location":"modules/uart/uart_tx/","title":"UART TX","text":""},{"location":"modules/uart/uart_tx/#description","title":"Description","text":""},{"location":"modules/uart/uart_tx/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps"},{"location":"modules/uart/uart_tx/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_P</code> std_logic in - Input asynchronous reset, active low <code>I_BYTE</code> vector[7:0] in - Input byte to send <code>I_BYTE_VALID</code> std_logic in - Input byte to send valid flag <code>O_UART_TX</code> std_logic out 0b1 Output UART TX line <code>O_DONE</code> std_logic out 0b0 Byte send flag"},{"location":"modules/uart/uart_tx/#architecture","title":"Architecture","text":"<p>The UART transmitter consists of three main components that work together to serialize and transmit data at the configured baud rate.</p> <p></p>"},{"location":"modules/uart/uart_tx/#clock-divider","title":"Clock Divider","text":"<p>A clock operating at the baud rate is generated internally to control the bit timing. This clock is activated when the transmitter enters the <code>STATE_SEND_BYTE</code> state.</p> <p>The clock divider process increment the bit count and shift the data every time it reaches one baud tick.</p>"},{"location":"modules/uart/uart_tx/#bit-counter","title":"Bit Counter","text":"<p>This counter ensures that:</p> <ul> <li>Exactly 8 data bits are transmitted</li> <li>The stop bit is sent after all data bits</li> <li>The transmitter returns to idle state after completing the frame</li> </ul> <p>The transmission sequence includes:</p> <ol> <li>Start bit (1 bit)</li> <li>Data bits (8 bits, LSB first)</li> <li>Stop bit (1 bit)</li> </ol> <p>Total frame length: 10 bits per byte</p>"},{"location":"modules/uart/uart_tx/#data-loading-and-shifting","title":"Data Loading and Shifting","text":"<p>The transmitter operates in two distinct modes for data handling:</p>"},{"location":"modules/uart/uart_tx/#state_idle-mode","title":"STATE_IDLE Mode","text":"<p>In the <code>STATE_IDLE</code> state, the shift register is loaded with the complete transmission frame when the valid flag is asserted. The frame structure is:</p> <pre><code>  [Stop bit | Data byte | Start bit]\n  [    1    | D7 ... D0 |     0    ]\n       \u2191                      \u2191\n     MSB of                 LSB of\nshift register         shift register\n</code></pre> <p>The frame is constructed as follows:</p> <ul> <li>Bit 0 (LSB): Start bit (logic '0')</li> <li>Bits 1-8: Data byte (D0 to D7)</li> <li>Bit 9 (MSB): Stop bit (logic '1')</li> </ul>"},{"location":"modules/uart/uart_tx/#state_send_byte-mode","title":"STATE_SEND_BYTE Mode","text":"<p>In the <code>STATE_SEND_BYTE</code> state, the shift register is shifted right by one position at each baud tick overflow. A logic '1' is shifted in from the left (MSB) side.</p> <p>This right-shift operation ensures that:</p> <ul> <li>Data bits are transmitted LSB first (as per UART standard)</li> <li>After all data bits are sent, logic '1' values (stop bit) are transmitted</li> <li>The shift register naturally returns to an idle-high state</li> </ul>"},{"location":"modules/uart/uart_tx/#output-signal","title":"Output Signal","text":"<p>The output signal <code>O_UART_TX</code> continuously reflects the LSB (bit 0) of the shift register, which contains the current bit being transmitted.</p> <pre><code>Transmission sequence for data byte 0x5A (0b01011010):\nTime \u2192\nBit  : [START| D0 | D1 | D2 | D3 | D4 | D5 | D6 | D7 |STOP]\nValue:   0     0    1    0    1    1    0    1    0    1\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   Transmitted on O_UART_TX\n</code></pre>"},{"location":"modules/uart/uart_tx/#fsm","title":"FSM","text":"<p>The UART FSM handling is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>I_BYTE_VALID = 1</code> T1 <code>bit_counter &gt;= 9</code> T2 Automatic"},{"location":"modules/vga/vga_controller/","title":"VGA Controller","text":""},{"location":"modules/vga/vga_controller/#description","title":"Description","text":"<p>The VGA Controller is a hardware module that generates timing signals for VGA video output.</p> <p>Only works for the TE 4-1734682-2 used on the Zedboard.</p>"},{"location":"modules/vga/vga_controller/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_H_PIXELS</code> integer 0d640 Horizontal resolution in pixels <code>G_H_FRONT_PORCH</code> integer 0d16 Horizontal front porch in pixels <code>G_H_SYNC_PULSE</code> integer 0d96 Horizontal synchronization pulse in pixels <code>G_H_BACK_PORCH</code> integer 0d48 Horizontal back porch in pixels <code>G_V_PIXELS</code> integer 0d480 Vertical resolution in pixels <code>G_V_FRONT_PORCH</code> integer 0d10 Vertical front porch in pixels <code>G_V_SYNC_PULSE</code> integer 0d2 Vertical synchronization pulse in pixels <code>G_V_BACK_PORCH</code> integer 0d33 Vertical back porch in pixels"},{"location":"modules/vga/vga_controller/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK_SYS</code> std_logic in - Input system clock <code>RST_SYS_P</code> std_logic in - Input system clock domain asynchronous reset, active high <code>I_MANUAL_COLORS</code> vector[11:0] in - Red color channel input (4-bit) &amp; Green color channel input (4-bit) &amp; Blue color channel input (4-bit) <code>CLK_VGA</code> std_logic in - Input vga clock <code>RST_VGA_P</code> std_logic in - Input VGA clock domain asynchronous reset, active high <code>O_HSYNC</code> std_logic out 0b0 Horizontal sync signal output <code>O_VSYNC</code> std_logic out 0b0 Vertical sync signal output <code>O_RED</code> vector[3:0] out 0x00 Red color channel output (blanked during inactive regions) <code>O_GREEN</code> vector[3:0] out 0x00 Green color channel output (blanked during inactive regions) <code>O_BLUE</code> vector[3:0] out 0x00 Blue color channel output (blanked during inactive regions) <code>O_H_POSITION</code> vector[15:0] out 0x00 Current horizontal pixel position within active region <code>O_V_POSITION</code> vector[15:0] out 0x00 Current vertical pixel position within active region <code>O_ACTIVE</code> std_logic out 0b0 Active display region flag (high during visible area) <p>The input vector <code>I_MANUAL_COLORS</code> is coming from the <code>CLK_SYS</code> clock domain and must be resynchronized to the <code>CLK_VGA</code> clock domain.</p>"},{"location":"modules/vga/vga_controller/#architecture","title":"Architecture","text":""},{"location":"modules/vga/vga_controller/#sub-modules","title":"Sub-modules","text":"<p>The VGA controller module instantiates the olo_base_cc_status module with the following generics:</p> Generic Name Type Default Value Description <code>Width_g</code> positive 0d12 Width of the data-signal to clock-cross <code>SyncStages_g</code> positive 0d2 Number of synchronization stages."}]}