{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"UART PROJECT","text":"<p>Documentation of the UART Project.</p>"},{"location":"#tools-versions","title":"Tools Versions","text":"Tool Version NVC <code>nvc 1.18.2 (1.18.2.r0.g8893318a5) (Using LLVM 18.1.3)</code> Vunit <code>commit 4e30fa124ea84609af0f957dbc55b82adaed1d76</code> VSG <code>VHDL Style Guide (VSG) version: 3.35.0</code> Vivado <code>2025.1</code>"},{"location":"#clocking-configuration","title":"Clocking Configuration","text":"<p>The FPGA uses a PLL (<code>clk_wiz_0</code>) to generate internal clocks from the input clock.</p>"},{"location":"#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>The FPGA defines the following inputs/outputs:</p> Pin Name Pin Number Direction Resistor Slew IOSTANDARD PAD_I_CLK Y9 in - - LVCMOS33 PAD_RST_H BTN6 in - - LVCMOS18 PAD_I_UART_RX Y11 in PULL-UP - LVCMOS33 PAD_O_UART_TX AA11 out PULL-UP - LVCMOS33 PAD_O_SCLK W12 out - - LVCMOS33 PAD_O_MOSI W11 out - - LVCMOS33 PAD_I_MISO W10 in - - LVCMOS33 PAD_O_CS W8 out PULL-UP - LVCMOS33 PAD_I_SWITCH_0 F22 in - - LVCMOS18 PAD_I_SWITCH_1 G22 in - - LVCMOS18 PAD_I_SWITCH_2 H22 in - - LVCMOS18 PAD_O_LED_0 T22 out - - LVCMOS33"},{"location":"bench/","title":"Testbench description","text":""},{"location":"bench/#overview","title":"Overview","text":"<p>The following figure depicts the Testbench:</p> <p></p>"},{"location":"bench/#types","title":"Types","text":""},{"location":"bench/#t_reg","title":"t_reg","text":"<p>A record type used to define register configurations for the testbench.</p> Property Description Type Name <code>t_reg</code> Purpose Register fields with address and default value Fields - <code>name</code> : <code>string</code> - Register name identifier- <code>addr</code> : <code>std_logic_vector(7 downto 0)</code> - 8-bit register address- <code>data</code> : <code>std_logic_vector(15 downto 0)</code> - 16-bit reset value"},{"location":"bench/#constants","title":"Constants","text":"<p>The following constants are defined:</p> Name Type Value Description <code>C_FREQ_HZ</code> positive 0d100_000_000 Clock frequency <code>C_CLK_PERIOD</code> time 1 sec / <code>C_FREQ_HZ</code> Clock period <code>C_GIT_ID</code> vector[31:0] 0x12345678 Git identifier for DUT version tracking <code>C_BAUD_RATE_BPS</code> positive 0d115_200 UART baud rate in bits per second <code>C_BIT_TIME</code> time 1 sec / <code>C_BAUD_RATE_BPS</code> Time duration for one UART bit <code>C_BIT_TIME_ACCURACY</code> time 0.01 * <code>C_BIT_TIME</code> UART bit timing tolerance (1%) <code>C_WRITE_NB_BITS</code> positive 10 * 8 Total bits for UART write command <code>C_UART_WRITE_CMD_TIME</code> time <code>C_BIT_TIME</code> * <code>C_WRITE_NB_BITS</code> Total time for UART write command <code>C_READ_NB_BITS</code> positive 10 * 9 Total bits for UART read command <code>C_UART_READ_CMD_TIME</code> time <code>C_BIT_TIME</code> * <code>C_READ_NB_BITS</code> Total time for UART read command"},{"location":"bench/#registers","title":"Registers","text":"<p>The following registers are defined as <code>t_reg</code>:</p> Name Address Reset Value <code>C_REG_GIT_ID_MSB</code> 0x00 0x1234 <code>C_REG_GIT_ID_LSB</code> 0x01 0x5678 <code>C_REG_12</code> 0x02 0x1212 <code>C_REG_34</code> 0x03 0x3434 <code>C_REG_56</code> 0x04 0x5656 <code>C_REG_78</code> 0x05 0x7878 <code>C_REG_9A</code> 0xAB 0x9A9A <code>C_REG_CD</code> 0xAC 0xCDCD <code>C_REG_EF</code> 0xDC 0xEFEF <code>C_REG_SWITCHES</code> 0xB1 0x0000 <code>C_REG_LED</code> 0xEF 0x0001 <code>C_REG_16_BITS</code> 0xFF 0x0000 <code>C_REG_DEAD</code> 0xCC 0xDEAD"},{"location":"modules/regfile/","title":"Registers","text":""},{"location":"modules/regfile/#description","title":"Description","text":"<p>Internal FPGA registers with read/write registers accessible via the UART line.</p>"},{"location":"modules/regfile/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_GIT_ID_MSB</code> vector[15:0] 0x0000 16 MSB of the git ID containing the sources for the bitstream generation <code>G_GIT_ID_LSB</code> vector[15:0] 0x0000 16 LSB of the git ID containing the sources for the bitstream generation"},{"location":"modules/regfile/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_N</code> std_logic in - Input asynchronous reset, active low <code>I_SWITCHES</code> vector[2:0] in - Input vector containing the resynchronized switches value <code>I_SPI_RX_DATA</code> vector[7:0] in - Input vector containing the SPI data sent by the slave <code>I_SPI_RX_DATA_VALID</code> std_logic in - Input vector containing the SPI data sent flag valid <code>I_READ_ADDR</code> vector[7:0] in - Read address from the UART <code>I_READ_ADDR_VALID</code> std_logic in - Read address valid flag <code>O_READ_DATA</code> vector[15:0] out <code>G_GIT_ID_MSB</code> Read data at the address <code>I_READ_ADDR</code> <code>O_READ_DATA_VALID</code> std_logic out 0 Read data valid flag <code>I_WRITE_ADDR</code> vector[7:0] in - Write address from the UART <code>I_WRITE_DATA</code> vector[15:0] in - Write data to be written at <code>I_WRITE_DATA</code> <code>I_WRITE_VALID</code> std_logic in - Write address and data valid flag <code>O_SPI_TX_DATA</code> vector[7:0] out - Input vector containing the SPI data to be send <code>O_SPI_TX_DATA_VALID</code> std_logic out - Input vector containing the SPI data flag valid <code>O_LED_0</code> std_logic out 1 LED 0 value"},{"location":"modules/regfile/#architecture","title":"Architecture","text":""},{"location":"modules/regfile/#read-operations","title":"Read Operations","text":"<p>The regfile module performs a read operation when <code>I_READ_ADDR_VALID</code> is asserted (set to '1'). The module responds by:</p> <ol> <li>Reading the data stored at the address specified by <code>I_READ_ADDR</code></li> <li>Asserting <code>O_READ_DATA_VALID</code> on the next clock cycle</li> <li>Outputting the retrieved value on <code>O_READ_DATA</code></li> </ol> <p>Invalid Address Handling:</p> <p>If the specified address does not correspond to a defined register, the module returns the sentinel value <code>0xDEAD</code> to indicate an invalid read operation.</p> <pre><code>Valid address:   I_READ_ADDR_VALID = '1' \u2192 O_READ_DATA = register[I_READ_ADDR]\nInvalid address: I_READ_ADDR_VALID = '1' \u2192 O_READ_DATA = 0xDEAD\n</code></pre>"},{"location":"modules/regfile/#write-operations","title":"Write Operations","text":"<p>The regfile module performs a write operation when <code>I_WRITE_VALID</code> is asserted (set to '1'). The module writes the data from <code>I_WRITE_DATA</code> to the address specified by <code>I_WRITE_ADDR</code>.</p> <p>Write Protection:</p> <p>Not all registers are writable. If the specified address corresponds to:</p> <ul> <li>A read-only register: The write operation is silently ignored, and the register value remains unchanged</li> <li>A writable register: The data is written on the next clock cycle</li> <li>An undefined address: The write operation is ignored</li> </ul>"},{"location":"modules/regfile/#overview","title":"Overview","text":"<p>A simplified view of the regfile module:</p> <p></p>"},{"location":"modules/regfile/#summary","title":"Summary","text":"Name Address Mode Description REG_GIT_ID_MSB 0x00 R 16 MSB of the git ID containing the sources for the bitstream generation REG_GIT_ID_LSB 0x01 R 16 LSB of the git ID containing the sources for the bitstream generation REG_12 0x02 R Internal register 1 REG_34 0x03 R Internal register 2 REG_56 0x04 R Internal register 3 REG_78 0x05 R Internal register 4 C_REG_SPI_TX_ADDR 0x06 RW Register controlling the SPI data to send C_REG_SPI_RX_ADDR 0x07 R Register containing the SPI slave data REG_9A 0xAB R Internal register 5 REG_CD 0xAC R Internal register 6 REG_EF 0xDC R Internal register 7 REG_SWITCHES 0xB1 R Status from the input switches REG_LED 0xEF RW Register with LSB bit writable controlling an LED REG_16_BITS 0xFF RW Register with all bits writable <p>Where:</p> Mode Description R Read-only: Register value can be read but not modified via write operations RW Read-Write: Register value can be both read and written"},{"location":"modules/regfile/#detailed-register-descriptions","title":"Detailed register descriptions","text":""},{"location":"modules/regfile/#reg_git_id_msb","title":"REG_GIT_ID_MSB","text":"<p>16 MSB of the git ID containing the sources for the bitstream generation</p> <ul> <li>Address: <code>0x00</code></li> </ul> Bits Reset Name Description 15:0 0x0 GIT_ID_MSB Most significant 16 bits of the Git commit ID"},{"location":"modules/regfile/#reg_git_id_lsb","title":"REG_GIT_ID_LSB","text":"<p>16 LSB of the git ID containing the sources for the bitstream generation</p> <ul> <li>Address: <code>0x01</code></li> </ul> Bits Reset Name Description 15:0 0x0 GIT_ID_LSB Least significant 16 bits of the Git commit ID"},{"location":"modules/regfile/#reg_12","title":"REG_12","text":"<p>Internal register 1</p> <ul> <li>Address: <code>0x02</code></li> </ul> Bits Reset Name Description 15:0 0x1212 Constant"},{"location":"modules/regfile/#reg_34","title":"REG_34","text":"<p>Internal register 2</p> <ul> <li>Address: <code>0x03</code></li> <li>Reset default: <code>0x3434</code></li> </ul> Bits Reset Name Description 15:0 0x3434 Constant"},{"location":"modules/regfile/#reg_56","title":"REG_56","text":"<p>Internal register 3</p> <ul> <li>Address: <code>0x04</code></li> <li>Reset default: <code>0x5656</code></li> </ul> Bits Reset Name Description 15:0 0x5656 Constant"},{"location":"modules/regfile/#c_reg_spi_tx_addr","title":"C_REG_SPI_TX_ADDR","text":"<p>SPI TX data register</p> <ul> <li>Address: <code>0x06</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:9 0x0 Reserved 8 0x0 TX_DATA_VALID 0 -&gt; 1 start the SPI transaction 7:0 0x0 TX_DATA TX data to be sent"},{"location":"modules/regfile/#c_reg_spi_rx_addr","title":"C_REG_SPI_RX_ADDR","text":"<p>SPI RX data register</p> <ul> <li>Address: <code>0x07</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:8 0x0 Reserved 7:0 0x0 RX_DATA Received data from SPI slave"},{"location":"modules/regfile/#reg_78","title":"REG_78","text":"<p>Internal register 4</p> <ul> <li>Address: <code>0x05</code></li> <li>Reset default: <code>0x7878</code></li> </ul> Bits Reset Name Description 15:0 0x7878 Constant"},{"location":"modules/regfile/#reg_9a","title":"REG_9A","text":"<p>Internal register 5</p> <ul> <li>Address: <code>0xAB</code></li> <li>Reset default: <code>0x9A9A</code></li> </ul> Bits Reset Name Description 15:0 0x9A9A Constant"},{"location":"modules/regfile/#reg_cd","title":"REG_CD","text":"<p>Internal register 6</p> <ul> <li>Address: <code>0xAC</code></li> <li>Reset default: <code>0xCDCD</code></li> </ul> Bits Reset Name Description 15:0 0xCDCD Constant"},{"location":"modules/regfile/#reg_ef","title":"REG_EF","text":"<p>Internal register 7</p> <ul> <li>Address: <code>0xDC</code></li> <li>Reset default: <code>0xEFEF</code></li> </ul> Bits Reset Name Description 15:0 0xEFEF Constant"},{"location":"modules/regfile/#reg_switches","title":"REG_SWITCHES","text":"<p>Register returning the status of the input switches</p> <ul> <li>Address: <code>0xB1</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:3 0x0 Reserved 2 0x0 SWITCH_2 Signal from PAD_I_SWITCH_2 1 0x0 SWITCH_1 Signal from PAD_I_SWITCH_1 0 0x0 SWITCH_0 Signal from PAD_I_SWITCH_0"},{"location":"modules/regfile/#reg_led","title":"REG_LED","text":"<p>Register with LSB bit writable controlling an LED</p> <ul> <li>Address: <code>0xEF</code></li> <li>Reset default: <code>0x0001</code></li> </ul> Bits Reset Name Description 15:1 0x0 Reserved 0 0x1 LED_0 Writable bit"},{"location":"modules/regfile/#reg_16_bits","title":"REG_16_BITS","text":"<p>Register with all bits writable</p> <ul> <li>Address: <code>0xFF</code></li> <li>Reset default: <code>0x0000</code></li> </ul> Bits Reset Name Description 15:0 0x0 DATA 16-bit writable data field"},{"location":"modules/resync_slv/","title":"Resync slv","text":""},{"location":"modules/resync_slv/#description","title":"Description","text":"<p>Re-synchronize asynchronous inputs to a destination clock domain using 3 DFF stages for each bit of the input vector.</p>"},{"location":"modules/resync_slv/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_WIDTH</code> positive 0d8 Width of the input/output vector <code>G_DEFAULT_VALUE</code> vector [G_WIDTH - 1:0] 0x00 Default value of the output vector"},{"location":"modules/resync_slv/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_N</code> std_logic in - Input asynchronous reset, active low <code>I_DATA_ASYNC</code> vector[G_WIDTH - 1:0] in - Input vector containing asynchronous signals <code>O_DATA_SYNC</code> vector[G_WIDTH - 1:0] out <code>G_DEFAULT_VALUE</code> Input vector resynchronized in <code>CLK</code> domain"},{"location":"modules/resync_slv/#overview","title":"Overview","text":""},{"location":"modules/resync_slv/#architecture","title":"Architecture","text":""},{"location":"modules/spi_master/","title":"SPI Master","text":""},{"location":"modules/spi_master/#description","title":"Description","text":""},{"location":"modules/spi_master/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>internal_clk</code> <code>G_SPI_FREQ_HZ</code> positive 0d500_000 SPI clock frequency in Hz <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits within the SPI transaction <code>G_CLK_POLARITY</code> std_logic 0b0 Generated SPI clock polarity <code>G_CLK_PHASE</code> std_logic 0b0 Generated SPI clock phase"},{"location":"modules/spi_master/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_N</code> std_logic in - Input asynchronous reset, active low <code>O_SCLK</code> std_logic out <code>G_CLK_POLARITY</code> Output SPI serial clock <code>O_MOSI</code> std_logic out 0b0 Output Master Out Slave In <code>I_MISO</code> std_logic in - Input Master In Slave Out <code>O_CS</code> std_logic out 0b1 Output chip select <code>I_TX_DATA</code> vector[G_NB_DATA_BITS-1:0] in - Data to be sent <code>I_TX_DATA_VALID</code> std_logic in - Data to be sent flag valid. Must be a rising edge to start the transaction (0 -&gt; 1) <code>O_TX_DATA</code> vector[G_NB_DATA_BITS-1:0] out 0x00 Data received from the slave <code>O_TX_DATA_VALID</code> std_logic out 0b0 Data Data received from the slave flag valid"},{"location":"modules/spi_master/#architecture","title":"Architecture","text":""},{"location":"modules/spi_master/#configuration","title":"Configuration","text":"<p>The SPI master supports all four standard SPI modes, determined by the Clock Polarity (CPOL) and Clock Phase (CPHA) settings:</p>"},{"location":"modules/spi_master/#mode-0-cpol0-cpha0","title":"Mode 0: CPOL=0, CPHA=0","text":"<p>Clock configuration with POLARITY = 0 and PHASE = 0</p> <p>In this mode:</p> <ul> <li>Clock idles low</li> <li>Data is output on the rising edge of SCLK</li> <li>Input data is sampled on the falling edge of SCLK</li> </ul>"},{"location":"modules/spi_master/#mode-1-cpol0-cpha1","title":"Mode 1: CPOL=0, CPHA=1","text":"<p>Clock configuration with POLARITY = 0 and PHASE = 1</p> <p>In this mode:</p> <ul> <li>Clock idles low</li> <li>Data is output on the falling edge of SCLK</li> <li>Input data is sampled on the rising edge of SCLK</li> </ul>"},{"location":"modules/spi_master/#mode-2-cpol1-cpha0","title":"Mode 2: CPOL=1, CPHA=0","text":"<p>Clock configuration with POLARITY = 1 and PHASE = 0</p> <p>In this mode:</p> <ul> <li>Clock idles high</li> <li>Data is output on the falling edge of SCLK</li> <li>Input data is sampled on the rising edge of SCLK</li> </ul>"},{"location":"modules/spi_master/#mode-3-cpol1-cpha1","title":"Mode 3: CPOL=1, CPHA=1","text":"<p>Clock configuration with POLARITY = 1 and PHASE = 1</p> <p>In this mode:</p> <ul> <li>Clock idles high</li> <li>Data is output on the rising edge of SCLK</li> <li>Input data is sampled on the falling edge of SCLK</li> </ul> <p>Note</p> <p>\"Output\" refers to when data is driven onto the MOSI/MISO lines. \"Sampled\" refers to when data is captured/registered from the input line.</p>"},{"location":"modules/spi_master/#fsm","title":"FSM","text":"<p>The UART FSM handling is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>i_data_valid_d1 = 0</code> AND <code>I_DATA_VALID = 1</code> (rising edge) T1 <code>spi_enable_sampling = 1</code> (trailing edge) T2 <code>spi_enable_shifting = 1</code> (leading edge) T3 <code>bit_counter &gt;= G_NB_DATA_BITS - 1</code> AND <code>spi_enable_shifting = 1</code> (all bits sent) T4 <code>spi_enable_sampling = 1</code> (trailing edge) T5 Automatic"},{"location":"modules/top_fpga/","title":"Top FPGA","text":""},{"location":"modules/top_fpga/#description","title":"Description","text":"<p>Top-Level of the FPGA.</p>"},{"location":"modules/top_fpga/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_GIT_ID</code> vector[31:0] 0x0000 Git ID containing the sources for the bitstream generation. Automatically set by the <code>run_synthesis.tcl</code> script."},{"location":"modules/top_fpga/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>PAD_I_CLK</code> std_logic in - Input clock <code>PAD_RST_H</code> std_logic in - Input asynchronous reset, active high <code>PAD_I_UART_RX</code> std_logic in - Input UART RX line <code>PAD_O_UART_TX</code> std_logic out 1 Output UART TX line <code>PAD_I_SWITCH_0</code> std_logic in - Input switch 0 <code>PAD_I_SWITCH_1</code> std_logic in - Input switch 1 <code>PAD_I_SWITCH_2</code> std_logic in - Input switch 2 <code>PAD_O_LED_0</code> std_logic out 1 Output LED 0"},{"location":"modules/top_fpga/#overview","title":"Overview","text":"<p>The following figure depicts the Top-Level:</p> <p></p>"},{"location":"modules/top_fpga/#architecture","title":"Architecture","text":""},{"location":"modules/top_fpga/#internal-reset","title":"Internal Reset","text":"<p>The FPGA internal reset <code>internal_rst_n</code> signal is generated by combining two conditions:</p> <ol> <li>The external reset button <code>PAD_I_RST_H</code> (active-high)</li> <li>The PLL lock status <code>pll_locked</code></li> </ol> <p>This ensures that the internal logic remains in reset until both the reset button is released and the PLL has achieved lock.</p>"},{"location":"modules/top_fpga/#resync-slv","title":"Resync-slv","text":"<p>The FPGA instantiates the resync_slv module with the following generics:</p> Generic Name Type Default Value Description <code>G_WIDTH</code> positive 0d3 Width of the input/output vector <code>G_DEFAULT_VALUE</code> vector [G_WIDTH - 1:0] 0b000 Default value of the output vector"},{"location":"modules/top_fpga/#uart","title":"UART","text":"<p>The FPGA instantiates the uart module with the following generics:</p> Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>internal_clk</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps <code>G_SAMPLING_RATE</code> positive 0d16 Sampling rate (number of clock cycles per bit) <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits"},{"location":"modules/top_fpga/#regfile","title":"Regfile","text":"<p>The FPGA instantiates the regfile module with the following generics:</p> Generic Name Type Default Value Description <code>G_GIT_ID_MSB</code> vector[15:0] <code>G_GIT_ID[31:16]</code> 16 MSB of the git ID containing the sources for the bitstream generation <code>G_GIT_ID_LSB</code> vector[15:0] <code>G_GIT_ID[15:0]</code> 16 LSB of the git ID containing the sources for the bitstream generation"},{"location":"modules/top_fpga/#spi-master","title":"SPI Master","text":"<p>The FPGA instantiates the spi_master module with the following generics:</p> Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>internal_clk</code> <code>G_SPI_FREQ_HZ</code> positive 0d1_000_000 SPI clock frequency in Hz <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits within the SPI transaction <code>G_CLK_POLARITY</code> std_logic 0b0 Generated SPI clock polarity <code>G_CLK_PHASE</code> std_logic 0b0 Generated SPI clock phase"},{"location":"modules/uart/","title":"UART","text":""},{"location":"modules/uart/#sub-modules","title":"Sub-modules","text":"<ul> <li>UART RX</li> <li>UART TX</li> </ul>"},{"location":"modules/uart/#description","title":"Description","text":""},{"location":"modules/uart/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps <code>G_SAMPLING_RATE</code> positive 0d16 Sampling rate (number of clock cycles per bit) <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits"},{"location":"modules/uart/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_N</code> std_logic in - Input asynchronous reset, active low <code>I_UART_RX</code> std_logic in - Asynchronous input UART RX line <code>O_UART_TX</code> std_logic out 0x1 Output UART TX line <code>O_READ_ADDR</code> vector[7:0] out 0x00 Output read address <code>O_READ_ADDR_VALID</code> std_logic out 0x0 Output read address valid flag <code>I_READ_DATA</code> vector[15:0] in - Input read data <code>I_READ_DATA_ADDR_VALID</code> std_logic in - Input read data valid <code>O_WRITE_ADDR</code> vector[7:0] out 0x00 Output write address <code>O_WRITE_DATA</code> vector[15:0] out 0x0000 Output write data <code>O_WRITE_VALID</code> std_logic out 0x0 Output write valid flag"},{"location":"modules/uart/#architecture","title":"Architecture","text":""},{"location":"modules/uart/#protocol","title":"Protocol","text":"<p>The implemented UART protocol is an ASCII-based protocol to access the internal registers of the FPGA. All commands and responses are ASCII text and every message is terminated by a mandatory carriage-return (CR, <code>\\r</code>). A line-feed (LF, <code>\\n</code>) may follow CR but is optional and ignored by the device.</p> <p>The following fields are defined:</p> <ul> <li><code>AA</code>: 8-bit address (two ASCII hex characters)</li> <li><code>DDDD</code>: 16-bit data (four ASCII hex characters)</li> </ul> <p></p>"},{"location":"modules/uart/#read-mode","title":"Read Mode","text":"<p>The read mode allows reading a 16-bit value from a specified 8-bit register address. The device responds with the current register value.</p> <p>Command Format</p> <pre><code>R + AA + \\r[\\n]\n</code></pre> <ul> <li><code>R</code>: literal ASCII 'R' (read command)</li> <li><code>AA</code>: two ASCII hex characters representing an 8-bit address (<code>00</code> .. <code>FF</code>)</li> <li><code>\\r</code>: mandatory CR terminator (ASCII 0x0D)</li> <li><code>\\n</code>: optional LF (ASCII 0x0A), if present it is ignored by the device</li> </ul> <p>Response Format</p> <pre><code>DDDD + \\r[\\n]\n</code></pre> <ul> <li><code>DDDD</code>: four ASCII hex characters representing the 16-bit register value, MSB first (<code>0000</code> .. <code>FFFF</code>)</li> <li><code>\\r</code>: mandatory CR terminator</li> <li><code>\\n</code>: optional LF (ASCII 0x0A)</li> </ul> <p>Examples</p> <pre><code># Read address 0x1A\nSent                   : R1A\\r\\n\nBytes transmitted (hex): 0x52 0x31 0x41 0x0D 0x0A\nReply                  : 0F3C\\r\nBytes received    (hex): 0x30 0x46 0x33 0x43 0x0D\n</code></pre> <pre><code># Read address 0xFF\nSent                   : RFF\\r\nBytes transmitted (hex): 0x52 0x46 0x46 0x0D\nReply                  : DEAD\\r\nBytes received    (hex): 0x44 0x45 0x39 0x44 0x0D\n</code></pre>"},{"location":"modules/uart/#write-mode","title":"Write Mode","text":"<p>The write mode allows writing a 16-bit value to a specified 8-bit register address. The device does not send any acknowledgment response after a successful write operation.</p> <p>Command Format</p> <pre><code>W + AA + DDDD + \\r[\\n]\n</code></pre> <ul> <li><code>W</code>: literal ASCII 'W' (write command)</li> <li><code>AA</code>: two ASCII hex characters representing an 8-bit address (<code>00</code> .. <code>FF</code>)</li> <li><code>DDDD</code>: four ASCII hex characters representing the 16-bit data value to write, MSB first (<code>0000</code> .. <code>FFFF</code>)</li> <li><code>\\r</code>: mandatory CR terminator (ASCII 0x0D)</li> <li><code>\\n</code>: optional LF (ASCII 0x0A), if present it is ignored by the device</li> </ul> <p>Response Format</p> <p>No response is expected or generated by the device for write commands.</p> <p>Important</p> <p>To verify that data was correctly written to the given address, perform a read-back operation using the read command on the same register address.</p> <p>Examples</p> <pre><code># Write value 0x1234 to address 0x1A\nSent                   : W1A1234\\r\\n\nBytes transmitted (hex): 0x57 0x31 0x41 0x31 0x32 0x33 0x34 0x0D 0x0A\nReply                  : (no reply expected)\n</code></pre> <pre><code># Write value 0x0001 to address 0x01\nSent                   : W010001\\r\nBytes transmitted (hex): 0x57 0x30 0x31 0x30 0x30 0x30 0x31 0x0D\nReply                  : (no reply expected)\n</code></pre>"},{"location":"modules/uart/#special-behavior","title":"Special behavior","text":"<p>Some transitions have special behavior: at every character received, the FSM checks if it is an <code>R</code> or <code>W</code> character. If detected, the FSM immediately abandons any ongoing operation and starts processing the new command.</p> <p>This means that a new read or write command can interrupt and completely override a partially received command, even if the previous command was not yet complete.</p> <p>Example: Interrupted Write Command</p> <pre><code># Sending the following ASCII characters: W001R00\\r\n#                                              \u2191\n#                              Sudden change to read command,\n#                              even though write command was incomplete\n\nSent       : W001R00\\r\nExpected   : Write incomplete data to address 0x00\nActual     : Read from address 0x00\nResult     : Returns the data at address 0x00\n             No write operation is performed\n</code></pre>"},{"location":"modules/uart/#fsm","title":"FSM","text":"<p>The UART FSM handling the above protocol is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>tx_byte_count &gt;= 5</code> T1 Automatic T2 <code>rx_byte_valid = 1</code> AND <code>(rx_byte = R character or rx_byte = W character)</code> T3 <code>rx_byte = W character</code> T4 <code>rx_byte = R character</code> T5 <code>rx_byte /= CR (\\r) character</code> AND <code>rx_byte_count &gt;= 3</code> T6 <code>rx_byte = CR (\\r) character</code> AND <code>rx_byte_count &gt;= 3</code> T7 Automatic T8 <code>I_READ_DATA_VALID = 1</code> T9 <code>rx_byte /= CR (\\r) character</code> AND <code>rx_byte_count &gt;= 7</code> T10 <code>rx_byte = CR (\\r) character</code> AND <code>rx_byte_count &gt;= 7</code>"},{"location":"modules/uart/#data-decoding","title":"Data decoding","text":"<p>The received data needs to be decoded from ASCII to hexadecimal to be usable in the registers. To do so, the signal <code>rx_byte_decoded</code> receives:</p> <p>ASCII to Hexadecimal Decoding</p> Decoded Value ASCII Character Condition <code>0x0</code> '0' <code>rx_byte = 0x30</code> <code>0x1</code> '1' <code>rx_byte = 0x31</code> <code>0x2</code> '2' <code>rx_byte = 0x32</code> <code>0x3</code> '3' <code>rx_byte = 0x33</code> <code>0x4</code> '4' <code>rx_byte = 0x34</code> <code>0x5</code> '5' <code>rx_byte = 0x35</code> <code>0x6</code> '6' <code>rx_byte = 0x36</code> <code>0x7</code> '7' <code>rx_byte = 0x37</code> <code>0x8</code> '8' <code>rx_byte = 0x38</code> <code>0x9</code> '9' <code>rx_byte = 0x39</code> <code>0xA</code> 'A' <code>rx_byte = 0x41</code> <code>0xB</code> 'B' <code>rx_byte = 0x42</code> <code>0xC</code> 'C' <code>rx_byte = 0x43</code> <code>0xD</code> 'D' <code>rx_byte = 0x44</code> <code>0xE</code> 'E' <code>rx_byte = 0x45</code> <code>0xF</code> 'F' <code>rx_byte = 0x46</code> <p>Special Characters</p> Character ASCII Value Condition Default/Invalid <code>0x00</code> No match found"},{"location":"modules/uart/#data-encoding","title":"Data encoding","text":"<p>The transmit data needs to be encoded from hexadecimal to ASCII before being sent over UART. To do so, the signal <code>tx_byte_to_send_encoded</code> receives:</p> <p>Hexadecimal to ASCII Encoding</p> Input Value ASCII Character Encoded Value <code>0x0</code> '0' <code>tx_byte_to_send_encoded = 0x30</code> <code>0x1</code> '1' <code>tx_byte_to_send_encoded = 0x31</code> <code>0x2</code> '2' <code>tx_byte_to_send_encoded = 0x32</code> <code>0x3</code> '3' <code>tx_byte_to_send_encoded = 0x33</code> <code>0x4</code> '4' <code>tx_byte_to_send_encoded = 0x34</code> <code>0x5</code> '5' <code>tx_byte_to_send_encoded = 0x35</code> <code>0x6</code> '6' <code>tx_byte_to_send_encoded = 0x36</code> <code>0x7</code> '7' <code>tx_byte_to_send_encoded = 0x37</code> <code>0x8</code> '8' <code>tx_byte_to_send_encoded = 0x38</code> <code>0x9</code> '9' <code>tx_byte_to_send_encoded = 0x39</code> <code>0xA</code> 'A' <code>tx_byte_to_send_encoded = 0x41</code> <code>0xB</code> 'B' <code>tx_byte_to_send_encoded = 0x42</code> <code>0xC</code> 'C' <code>tx_byte_to_send_encoded = 0x43</code> <code>0xD</code> 'D' <code>tx_byte_to_send_encoded = 0x44</code> <code>0xE</code> 'E' <code>tx_byte_to_send_encoded = 0x45</code> <code>0xF</code> 'F' <code>tx_byte_to_send_encoded = 0x46</code> <p>Special Characters</p> Character ASCII Value Condition Carriage Return (CR) <code>0x0D</code> <code>tx_byte_count = C_TX_DATA_BYTES</code> Default/Invalid <code>0x00</code> No match found"},{"location":"modules/uart_rx/","title":"UART RX","text":""},{"location":"modules/uart_rx/#description","title":"Description","text":""},{"location":"modules/uart_rx/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps <code>G_SAMPLING_RATE</code> positive 0d16 Sampling rate (number of clock cycles per bit) <code>G_NB_DATA_BITS</code> positive 0d8 Number of data bits"},{"location":"modules/uart_rx/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_N</code> std_logic in - Input asynchronous reset, active low <code>I_UART_RX</code> std_logic in - Asynchronous input UART RX line <code>O_BYTE</code> vector[7:0] out 0x00 Output byte <code>O_BYTE_VALID</code> std_logic out 0x0 Output byte valid flag <code>O_START_BIT_ERROR</code> std_logic out 0x0 Output start bit error flag <code>O_STOP_BIT_ERROR</code> std_logic out 0x0 Output stop bit error flag"},{"location":"modules/uart_rx/#architecture","title":"Architecture","text":"<p>The UART receiver must synchronize to incoming data, sample at the correct time, handle noise, and detect framing errors. The receiver uses oversampling, digital filtering, and majority voting to ensure reliable data reception.</p>"},{"location":"modules/uart_rx/#oversampling-clock","title":"Oversampling Clock","text":"<p>The receiver generates an internal sampling clock that runs at a multiple of the baud rate (configured by <code>G_SAMPLING_RATE</code>, typically 16).</p> <p>The oversampling clock divider generates a tick (<code>rx_baud_tick</code>) at the oversampling rate. For example, with 16\u00d7 oversampling and 115200 baud:</p> \\[f_{oversample} = 115200 \\times 16 = 1.8432\\text{ MHz}\\] <p>The clock divider is enabled during active reception and reset during idle to ensure proper synchronization with incoming data.</p> <p>Note</p> <p>The oversampling rate is configurable via the <code>G_SAMPLING_RATE</code> generic. A higher rate provides better noise immunity but requires a faster system clock.</p>"},{"location":"modules/uart_rx/#input-synchronization-and-filtering","title":"Input Synchronization and Filtering","text":"<p>The asynchronous UART RX input must be properly synchronized to prevent metastability and filtered to remove noise.</p> <p>Synchronization Chain</p> <p>A 5-stage shift register processes the incoming signal:</p> <pre><code>Stage 0-1: Metastability resolution (2 flip-flops)\nStage 2-4: Digital filtering (3 consecutive samples)\n\nI_UART_RX \u2192 [FF] \u2192 [FF] \u2192 [Filter] \u2192 [Filter] \u2192 [Filter] \u2192 i_uart_rx_filtered\n</code></pre> <p>Digital Filtering Logic</p> <p>The filter uses a simple majority voting algorithm on the last 3 stages:</p> Input Samples (bits 4:2) Filtered Output Description <code>000</code> <code>0</code> All zeros \u2192 output low <code>111</code> <code>1</code> All ones \u2192 output high Other patterns Keep previous value Insufficient agreement <p>Important</p> <p>The first 2 bits of the shift register are potentially metastable and must NOT be used for any logic decisions. Only bits [4:2] are used for filtering. (I made this mistake)</p> <p>Edge Detection</p> <p>A delayed version of the filtered signal (<code>i_uart_rx_filtered_d1</code>) is maintained to detect edges:</p> <ul> <li>Falling edge (<code>1</code> \u2192 <code>0</code>): Indicates start bit detection</li> <li>Rising edge (<code>0</code> \u2192 <code>1</code>): Used for stop bit validation</li> </ul>"},{"location":"modules/uart_rx/#oversampling-and-bit-timing","title":"Oversampling and Bit Timing","text":"<p>Each UART bit period is divided into multiple sampling intervals. With 16\u00d7 oversampling, each bit period contains 16 ticks.</p> <p>Tick Counting</p> <p>The <code>oversampling_counter</code> counter tracks the position within the current bit period:</p> <ul> <li>Increments on each <code>rx_baud_tick</code></li> <li>Resets to 0 after reaching <code>C_OVERSAMPLE_MAX</code> (15 for 16\u00d7 oversampling)</li> <li>When it wraps, one complete bit period has elapsed</li> </ul> <p>Visual Timing Diagram</p> <pre><code>Idle/Previous Bit                           Current Data Bit                           Next Bit\n     (High)                                     (Low)                                   (High)\n________________                                                                 __________________\n                \\                                                               /\n                 \\                                                             /\n                  \\                                                           /\n                   \\_________________________________________________________/\n\nTick:                 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15\nSamples:                                      ^\n                                       Sample Point\n\nLegend:\n- 16 ticks per bit period (numbered 0-15)\n- Samples taken at tick\n- Provides maximum timing margin from bit edges\n</code></pre> <p>Sample Point Selection</p> <p>The mid-bit sample point is calculated as:</p> \\[\\text{mid bit} = \\frac{G\\_BAUD\\_RATE\\_BPS - 1}{2}\\]"},{"location":"modules/uart_rx/#bit-counter","title":"Bit Counter","text":"<p>The <code>data_counter</code> counter tracks how many data bits have been received.</p>"},{"location":"modules/uart_rx/#data-shift-register","title":"Data Shift Register","text":"<p>The <code>next_o_byte</code> register accumulates the incoming data bits.</p> <p>Shifting Operation</p> <p>Data is received LSB first (UART standard). Each new bit is shifted in from the left (MSB side):</p> <pre><code>next_o_byte &lt;= uart_rx_sampled_bit &amp; next_o_byte(7 downto 1);\n</code></pre> <p>Example Reception Sequence</p> <p>Receiving byte <code>0x5A</code> (<code>0b01011010</code>):</p> <pre><code>Initial:      next_o_byte = xxxxxxxx\n\nBit 0 (D0=0): next_o_byte = 0xxxxxxx  (shift in 0)\nBit 1 (D1=1): next_o_byte = 10xxxxxx  (shift in 1)\nBit 2 (D2=0): next_o_byte = 010xxxxx  (shift in 0)\nBit 3 (D3=1): next_o_byte = 1010xxxx  (shift in 1)\nBit 4 (D4=1): next_o_byte = 11010xxx  (shift in 1)\nBit 5 (D5=0): next_o_byte = 011010xx  (shift in 0)\nBit 6 (D6=1): next_o_byte = 1011010x  (shift in 1)\nBit 7 (D7=0): next_o_byte = 01011010  (shift in 0)\n\nFinal:        next_o_byte = 0x5A \u2713\n</code></pre> <p>The byte is complete after 8 bits and ready to be latched to the output if the stop bit is valid.</p>"},{"location":"modules/uart_rx/#error-recovery-mechanism","title":"Error Recovery Mechanism","text":"<p>When an invalid start bit is detected, the module enters an error recovery state to prevent false triggering on glitches or noise.</p> <p>The module then waits for the following time before going back to idle and accept new RX requests:</p> \\[\\text{RECOVERY\\_PERIOD} = G\\_SAMPLING\\_RATE \\times (G\\_NB\\_DATA\\_BITS + 1)\\] <p>This represents the time for almost one complete UART frame (data bits + stop bit) at the configured baud rate.</p>"},{"location":"modules/uart_rx/#fsm","title":"FSM","text":"<p>The UART RX FSM is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>i_uart_rx_filtered_d1 = 1</code> AND <code>i_uart_rx_filtered = 0</code> (falling edge on the UART line) T1 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = G_SAMPLING_RATE - 1</code> AND <code>uart_rx_sampled_bit = 1</code> (invalid start bit = 1) T2 Automatic T3 <code>recovery_elapsed = 1</code> T4 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = G_SAMPLING_RATE - 1</code> AND <code>uart_rx_sampled_bit = 0</code> (valid start bit = 0) T5 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = G_SAMPLING_RATE - 1</code> AND <code>data_counter = G_NB_DATA_BITS - 1</code> T6 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = C_THREE_QUARTER_POINT - 1</code> AND <code>uart_rx_sampled_bit = 0</code> (invalid stop bit = 0) T7 Automatic T8 <code>rx_baud_tick = 1</code> AND <code>oversampling_counter = C_THREE_QUARTER_POINT - 1</code> AND <code>uart_rx_sampled_bit = 1</code> (valid stop bit = 1) T9 Automatic <p>Note</p> <p>Early Stop Bit Exit for Burst Support</p> <p>The module exits the stop bit at 3/4 of the bit period (tick 12 of 16) after validation at mid-point (tick 8). This enables zero-gap back-to-back frame reception for burst transmissions.</p>"},{"location":"modules/uart_tx/","title":"UART TX","text":""},{"location":"modules/uart_tx/#description","title":"Description","text":""},{"location":"modules/uart_tx/#generics","title":"Generics","text":"Generic Name Type Default Value Description <code>G_CLK_FREQ_HZ</code> positive 0d50_000_000 Clock frequency in Hz of <code>CLK</code> <code>G_BAUD_RATE_BPS</code> positive 0d115_200 Baud rate in bps"},{"location":"modules/uart_tx/#inputs-and-outputs","title":"Inputs and Outputs","text":"Port Name Type Direction Default Value Description <code>CLK</code> std_logic in - Input clock <code>RST_N</code> std_logic in - Input asynchronous reset, active low <code>I_BYTE</code> vector[7:0] in - Input byte to send <code>I_BYTE_VALID</code> std_logic in - Input byte to send valid flag <code>O_UART_TX</code> std_logic out 0x1 Output UART TX line <code>O_DONE</code> std_logic out 0x0 Byte send flag"},{"location":"modules/uart_tx/#architecture","title":"Architecture","text":"<p>The UART transmitter consists of three main components that work together to serialize and transmit data at the configured baud rate.</p>"},{"location":"modules/uart_tx/#clock-divider","title":"Clock Divider","text":"<p>A clock operating at the baud rate is generated internally to control the bit timing. This clock is activated when the transmitter enters the <code>STATE_SEND_BYTE</code> state.</p> <p>The clock divider process increment the bit count and shift the data every time it reaches one baud tick.</p>"},{"location":"modules/uart_tx/#bit-counter","title":"Bit Counter","text":"<p>This counter ensures that:</p> <ul> <li>Exactly 8 data bits are transmitted</li> <li>The stop bit is sent after all data bits</li> <li>The transmitter returns to idle state after completing the frame</li> </ul> <p>The transmission sequence includes:</p> <ol> <li>Start bit (1 bit)</li> <li>Data bits (8 bits, LSB first)</li> <li>Stop bit (1 bit)</li> </ol> <p>Total frame length: 10 bits per byte</p>"},{"location":"modules/uart_tx/#data-loading-and-shifting","title":"Data Loading and Shifting","text":"<p>The transmitter operates in two distinct modes for data handling:</p> <p>STATE_IDLE Mode</p> <p>In the <code>STATE_IDLE</code> state, the shift register is loaded with the complete transmission frame when the valid flag is asserted. The frame structure is:</p> <pre><code>  [Stop bit | Data byte | Start bit]\n  [    1    | D7 ... D0 |     0    ]\n       \u2191                      \u2191\n     MSB of                 LSB of\nshift register         shift register\n</code></pre> <p>The frame is constructed as follows:</p> <ul> <li>Bit 0 (LSB): Start bit (logic '0')</li> <li>Bits 1-8: Data byte (D0 to D7)</li> <li>Bit 9 (MSB): Stop bit (logic '1')</li> </ul> <p>STATE_SEND_BYTE Mode</p> <p>In the <code>STATE_SEND_BYTE</code> state, the shift register is shifted right by one position at each baud tick overflow. A logic '1' is shifted in from the left (MSB) side.</p> <p>This right-shift operation ensures that:</p> <ul> <li>Data bits are transmitted LSB first (as per UART standard)</li> <li>After all data bits are sent, logic '1' values (stop bit) are transmitted</li> <li>The shift register naturally returns to an idle-high state</li> </ul> <p>Output Signal</p> <p>The output signal <code>O_UART_TX</code> continuously reflects the LSB (bit 0) of the shift register, which contains the current bit being transmitted.</p> <pre><code>Transmission sequence for data byte 0x5A (0b01011010):\n\nTime \u2192\nBit  : [START| D0 | D1 | D2 | D3 | D4 | D5 | D6 | D7 |STOP]\nValue:   0     0    1    0    1    1    0    1    0    1\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   Transmitted on O_UART_TX\n</code></pre>"},{"location":"modules/uart_tx/#fsm","title":"FSM","text":"<p>The UART FSM handling is defined as:</p> <p></p> <p>Where the following transitions are defined:</p> Transition Condition(s) T0 <code>I_BYTE_VALID = 1</code> T1 <code>tx_current_bit_index &gt;= 9</code> T2 Automatic"}]}